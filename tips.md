# 一些看书积累的小TIPS

## 类型选择

1. 明确知道数值不为负数时，选择无符号类型
2. 整数运算用 int，超过范围用 long long
3. 算术表达式不要用 char 或 bool
4. 浮点数用double

## 带符号类型和无符号类型

不要混用带符号类型和无符号类型

## 初始化变量

建议初始化每一个内置类型的变量

## 变量命名规范

1. 标识符要能体现实际含义
2. 变量一般用小写字母，如index
3. 自定义类名一般大写字母开头，如Sales_item
4. 多个单词之间应该有明显区分，如student_loan

## 变量定义

建议在对象第一次被使用的地方附近定义它

如果函数有可能用到某全局变量，不建议再定义一个同名的局部变量

## 指针初始化

建议初始化所有指针

## 头文件保护符

习惯性地加上头文件保护符，避免被重复包含

## 头文件不应包含using声明

头文件不应包含using声明，因为头文件的内容会被拷贝到所有引用它的文件中，一不小心就容易出现冲突

## 无需定义vector大小

定义vector对象时，设定其大小可能会使性能更差，所以不必在创建时顺便指定容量

## 数组 or vector？

数组大小确定不变，对于某些应用来说性能更好，**但如果不确定元素的确切个数，建议使用vector**

## 尽量使用标准库类型

现代C++程序应尽量使用vector和迭代器，避免使用内置数组和指针，尽量使用string，避免使用C风格的基于数组的字符串

## range for使用引用类型

```cpp
size_t cnt = 0;
for (auto &row : ia){
	for(auto col : row) {
            col = cnt;
            ++cnt;
	}
}
```

**为什么要声明引用类型？**即使没有任何写操作，但是为了避免数组被自动转成指针，还是声明了引用类型，假设不适用引用类型，row将会被转换成指向该数组内首元素的指针，这样得到的row类型是int*，内层的循环将不合法

**因此，要使用range for处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型**

## 前置递增递减

**建议除了非必须，否则不用后置版本，坚持使用前置版本++i**，原因是后置版本需要将原始值存储下来以便返回这个未修改的内容，而对于整数和指针类型来说，编译器可能会有一定的优化，但是对于复杂的迭代器类型，这种额外工作的消耗就巨大了。

## 避免强制类型转换

强烈建议程序员避免使用强制类型转换！

## break

建议每个case后都加上break，不管需不需要

## default

即使不准备在default标签下做任何工作，定义一个default标签也是有用的，其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做

## goto

不要在程序里使用goto，因为它让程序变得既难理解又难修改

## 引用类型的形参

熟悉C的程序员常常使用指针类型的形参访问函数外部的对象，但在C++中，建议使用引用类型的形参代替指针

## 使用传引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

## 使用引用形参返回额外信息

一个函数只能返回一个值，然而有时候函数需要返回多个值，可以使用引用形参
我们可以把实参传入，实参在函数运行后值会改变，变相返回了额外信息

## 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。

此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

## 不要返回局部对象的引用或指针

返回局部对象的引用和指针是错误的，一旦函数完成，局部对象将被释放，指针将指向一个不存在的对象

## 尾置返回类型

C++11可以使用尾置返回类型，任何函数的定义都能使用尾置返回，定义返回类型比较复杂的函数最有用，比如返回类型是数组的指针或引用

```cpp
auto func(int i) -> int(*)[10];
```

```cpp
int (*f1(int))(int*, int);
// 等价于
auto f1(int) -> int (*)(int*, int);
```

## \_\_xxx\_\_

1. \_\_func\_\_，可以输出当前调试的函数的名字，编译器为每个函数都定义了\_\_func\_\_
2. \_\_FILE\_\_，存放文件名的字符串字面值
3. \_\_LINE\_\_，存放当前行号的整形字面值
4. \_\_TIME\_\_，存放文件编译时间的字符串字面值
5. \_\_DATE\_\_，存放文件编译日期的字符串字面值

## class、struct

struct和class的**唯一一点区别**是，它们的默认访问权限不一样。

使用struct，在定义一个访问说明符之前的成员是public的，相反，如果我们使用class，则成员是private的

## 友元

一般来说，最好在类定义开始或结束前的位置集中声明友元

## 构造函数初始值顺序

最好令构造函数初始值的顺序与成员声明的顺序保持一致，而且如果可能的话，尽量避免使用某些成员初始化其他成员

因为成员的初始化顺序只与他们在类定义中出现的顺序一致

## 箭头运算符

C++定义了箭头运算符(->)，目的就是为了把**解引用和成员访问两个操作结合**在一起，二者表达的意思相同

```cpp
it->mem
(*it).mem
```

## new&delete易错点

1. 忘记delete内存，出现内存泄漏
2. 使用已经释放掉的内存
3. 同一块内存释放两次

**因此要坚持只使用智能指针，避免这些问题！对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它**

## 智能指针

1. 不要混合使用普通指针和智能指针
2. 不要使用get初始化另一个智能指针或为智能指针赋值
3. 只有在确定代码不会delete指针的情况下才使用get
4. 不使用相同的内置指针值初始化(或reset)多个智能指针(尽量使用make_shared)
5. 如果使用get返回的指针，记住当最后一个对应的智能指针被销毁后，get的指针就无效了
6. 如果使用智能指针管理的资源不是new分配的内存，记得传递一个删除器

## 拷贝控制

在定义任何C++类时，拷贝控制操作都是必要部分，如果不显式定义，编译器定义的版本的行为往往出乎意料

## 析构函数

析构函数体自身并不直接销毁成员，成员是在析构函数体之外隐含的析构阶段中被销毁的

## 三/五法则

1. 拷贝构造函数(copy constructor)

2. 拷贝赋值运算符（copy-assignment operator)

3. 析构函数（destructor)

   

4. 移动构造函数(move constructor)

5. 移动赋值运算符（move-assignment operator)

C++并不要求我们定义所有这些操作，可以只定义其中的一个或两个，但这些操作通常应该被看作一个整体，通常只需要其中一个操作而不需要定义所有操作的情况是很少见的

### 需要析构函数的类也需要拷贝和赋值操作

对析构函数的需求比拷贝构造或赋值的需求更为明显，如果这个类需要一个析构函数，则几乎肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符

### 需要拷贝操作的类也需要赋值操作，反之亦然

如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。

然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

### 定义了任何一个拷贝操作，就应该定义所有五个操作

某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作，这些类通常拥有一个资源，而拷贝成员必须拷贝此资源，一般来说，拷贝资源会导致额外开销，因此在非必要情况下，定义移动构造函数和移动赋值运算符的类可以避免此问题

## 使用=default

可以定义=default显示要求编译器生成合成的版本

```cpp
class Sales_data {
public:
    //拷贝控制成员；使用default
    Sales_data() = default;
    Sales_data (const Sales_data&) = default;
    Sales_data& operator=(const Sales_data&);
    ~Sales_data () = default;
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

当我们在类内使用=default时，合成的函数将隐式声明为内联，如果不希望时内联，则应该对成员的类外定义使用=default

## move

虽然不能将一个右值引用直接绑定到一个左值上，但是可以显式地将一个左值转换为对应的右值引用，可以调用move来获得绑定到左值上的右值引用

```cpp
int &&rr3 = std::move(rr1); // ok
```

move调用告诉编译器：我们有一个左值，但我希望像一个右值一样处理它，这就意味着承诺：除了对rr1赋值或销毁它之外，我们将不再使用它，在调用move之后，我们不能对移后源对象做任何假设

**我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象**

**应该使用std::move而不是move，也不用using声明，这样做可以避免潜在的名字冲突**

## 移后源对象必须可析构

在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设，即不能猜测其值是多少

## 合成的移动操作

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符

## 移动操作和合成的拷贝控制成员

定义了一个移动构造函数或移动赋值运算符的类必须也定义自已的拷贝操作。否则，这些成员默认地被定义为删除的。

## 如果没有移动构造函数，右值被拷贝

如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。

## 不要随意使用移动操作

由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。

通过在类代码中小心地使用move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。

**在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std::move。**

## 区别拷贝和复制

区分拷贝和移动的重载函数通常有一个版本接受一个const T&，而另一个版本接受一个T&&

例如，定义了push_back的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。假定x是元素类型，那么这些容器就会定义以下两个push_back版本：

```cpp
void push_back(const X&) ; //拷贝：绑定到任意类型的x
void push_back(X&&); 	  //移动：只能绑定到类型x的可修改的右值
```

调用的差别在于实参是一个左值还是右值
