# 用于大型程序的工具

本章介绍编写比较复杂的、小组和个人难以管理的系统时，最为有用的特性

1. 异常处理
2. 命名空间
3. 多重继承和虚继承

## 18.3 多重继承与虚继承

多重继承(multiple inheritance)是指从多个直接基类中产生派生类的能力，多重继承的派生类继承了所有父类的属性

## 18.3.1 多重继承

在派生类的派生列表中可以包含多个基类：
```cpp
class Bear : public ZooAnimal {};
class Panda : public Bear, public Endangered {	};
```

每个基类包含一个可选的访问说明符，如果被忽略掉，则默认访问说明符是private，关键字struct的是public

和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。

## 18.3.2 类型转换与多个基类

多个基类的情况下，派生类的指针或引用仍然可以自动转换成一个可访问基类的指针或引用

编译器不会在派生类向基类的集中转换中进行比较和选择，因为在编译器看来，转换到任意一种基类都一样好

## 18.3.4 虚继承

尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。

在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。

这种情况对于某些类肯定是行不通的，因此我们通过虚继承（virtual inheritance）的机制解决这个问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类（virtual base class)。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

### 使用虚基类

我们指定虚基类的方式是在派生列表中添加关键字virtual：

```cpp
// 关键字public和virtual的顺序随意
class Raccoon : public virtual ZooAnimal { /* ...*/ };
class Bear : virtual public ZooAnimal ( /* ..*/ };
```

通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。