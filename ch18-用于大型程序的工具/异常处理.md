# 用于大型程序的工具

本章介绍编写比较复杂的、小组和个人难以管理的系统时，最为有用的特性

1. 异常处理
2. 命名空间
3. 多重继承和虚继承

## 18.1.1 抛出异常

异常被抛出时，throw后的语句不再执行，控制权从throw转移到与之匹配的catch模块，该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中

控制权的转移有两个重要的含义：

- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁

因为跟在throw后的语句不再执行，因此throw用法有点类似return，一般作为条件语句的一部分或者作为某个函数的最后（唯一一条）语句

### 栈展开

栈展开过程沿着嵌套函数的调用链不断查找，寻找与try匹配的catch，直到找到为止，或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止

假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码，当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行

**一个异常如果没有被捕获，则它将终止当前的程序**

### 栈展开过程中对象被自动销毁

栈展开过程中，位于调用链上的语句块可能会提前退出，程序在这些块中创建了一些局部对象，块推出后它的局部对象也将随之销毁，这条规则对于栈展开规则同样适用。如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用

### 析构函数与异常

析构函数不应该抛出不能被它自身处理的异常，一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止

## 18.1.2 捕获异常

### 重新抛出

有时候一个单独的catch不能完整处理整个异常，此时可以重新抛出(rethrowing)，将异常传递给另一个catch，这里的重新抛出仍然是一条throw，但是不包含任何表达式

```cpp
throw;
```

空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。

### 捕获所有异常

捕获所有异常(catch-all)，我们用省略号作为异常声明，一条捕获所有异常的语句可以与任意类型的异常匹配

```cpp
void manip() {
	try {
		// 抛出异常
	} catch (...) {
		// 处理异常的某些特殊操作
		throw;
	}
}
```

catch(...)既能单独出现，也能和其他几个catch语句一起出现，只不过必须出现在最后的位置，因为如果出现之前，后边的catch语句将不会被匹配

### 函数try语句块与构造函数

把关键字try写在构造函数名之后，紧接着函数体，表示与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常

```cpp
ClassName::ClassName(parameters) 
try : member1(...), member2(...)  {
    // 构造函数体
} catch (...) {
    // 这里可以捕获：
    // 1. 成员初始化列表中抛出的异常
    // 2. 构造函数函数体中抛出的异常
}
```

## 18.1.4 noexcept异常说明

对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。

在C++11中，可以提供noexcept说明指定某个函数不会抛出异常

```cpp
void recoup(int) noexcept;
```

### 违反异常说明

编译器并不会在编译时检查noexcept说明，实际上如果一个函数既noexcept但又throw异常，编译器仍然可以顺利编译通过

一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺，因此noexcept可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道如何处理该异常

### 异常说明的实参

noexcept接受一个可选的实参，实参必须能被转换为bool类型，如果实参为true，则函数不会抛出异常，如果为false，则可能抛出异常

## 18.1.5 异常类层次

![image-20250815172514008](https://s2.loli.net/2025/08/15/fC1KGmUA9ouaRHc.png)

和其他继承体系一样，异常类也可以看作按照层次关系组织的。

层次越低，表示的异常情况就越特殊。例如，在异常类继承体系中位于最顶层的通常是exception，exception表示的含义是某处出错了，至于错误的细节则未作描述。

继承体系的第二层将exception划分为两个大的类别：运行时错误和逻辑错误。运行时错误表示的是只有在程序运行时才能检测到的错误：而逻辑错误一般指的是我们可以在程序代码中发现的错误。
