# 用于大型程序的工具

本章介绍编写比较复杂的、小组和个人难以管理的系统时，最为有用的特性

1. 异常处理
2. 命名空间
3. 多重继承和虚继承

## 18.2 命名空间

大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution)

命名空间（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。

## 18.2.1 命名空间定义

```cpp
namespace cpp_primer{

} // 命名空间结束无需分号
```

和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。

### 每个命名空间都是一个作用域

位于命名空间之外的代码应明确指出所用的名字属于哪个命名空间

### 命名空间可以是不连续的

当我们使用namespace时，如果之前没有相关的定义，则创建一个新的命名空间，如果已经有了，则打开之前已经存在的命名空间定义并为其添加一些新成员的声明

### 全局命名空间

全局作用域中定义的名字定义在全局命名空间中，全局命名空间以隐式的方式声明，并且在所有程序中都存在，全局作用域中定义的名字被隐式地添加到全局命名空间中

```cpp
::member_name
```

作用域运算符可以通过上述方式用于全局作用域的成员

### 内联命名空间

正常的嵌套命名空间，内存的命名空间会隐藏外层命名空间中的同名成员

如果将内层声明为内联，则外层命名空间可以直接使用内联命名空间中的名字，无需添加前缀

```cpp
inline namespace fifth {

}
namespace fifth { // 隐式内联

}
```

关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline，也可以不写。

### 未命名的命名空间

未命名的命名空间(unnamed namespace)是指关键字namespace后紧跟花括号括起来的一系列声明语句

**未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。**

一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。

定义在未命名的命名空间中的名字可以直接使用，毕竞我们找不到什么命名空间的名字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。

**未命名的命名空间取代文件中的静态声明**
在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为static的全局实体在其所在的文件外不可见。

**在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。**

## 18.2.2 使用命名空间成员

当命名空间名字很长时，使用命名空间的成员显然非常繁琐，我们可以用简便的方法使用命名空间的成员

### 命名空间的别名

```cpp
namespace cplusplus_primer  {	};
namespace primer = cplusplus_primer; // 声明别名

// 也可指向嵌套的命名空间
namespace Qlib = cplusplus_primer::QueryLib;
Qlib::Query q;
```

一个命名空间可以有多个同义词或别名，所有别名都与命名空间原来的名字等价

### using声明

一条using声明语句一次只引入命名空间的一个成员，使得我们可以清楚地直到程序中用的到底是哪个名字

**using声明(using declaration)**引入的名字，有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止

### using指示

**using指示(using directive)**，和using声明类似的地方是，我们可以用命名空间的简写形式，后面是关键字namespace以及命名空间的名字，这里所用的名字必须是已经定义好的命名空间的名字，否则程序将发生错误

using指示是的某个特定的命名空间中的所有名字都可见，这样我们无需再为其添加任何前缀限定符了，简写的名字从using指示开始，一直到using指示所在的作用域结束前都可以使用

### 避免using指示

using指示一次性注入某个命名空间的所有名字，这种用法看似简单实则充满了风险：只使用一条语句就突然将命名空间中所有成员的名字变得可见了。如果应用程序使用了多个不同的库，而这些库中的名字通过using指示变得可见，则全局命名空间污染的问题将重新出现

相比于使用using指示,在程序中对命名空间的每个成员分别使用using声明效
果更好，这么做可以减少注入到命名空间中的名字数量。using声明引起的二义性问题在声明处就能发现，无须等到使用名字的地方，这显然对检测并修改错误大有益处

## 18.2.3 类、命名空间与作用域

### 实参相关的查找与类类型形参

考虑下面这个简单的程序：

```cpp
std::string s;
std::cin >> s;

// 该调用等价于
operator>>(std::cin, s);
```

operator>>函数定义在标准库string中，string又定义在命名空间std中。但是我们不用std::限定符和using声明就可以调用 operator>>

对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。

在此例中，当编译器发现对operator>>的调用时，首先在当前作用域中寻找合适的函数，接着查找输出语句的外层作用域。随后，因为>>表达式的形参是类类型的，所以编译器还会查找cin和s的类所属的命名空间。也就是说，对于这个调用来说，编译器会查找定义了istream和string的命名空间std。

当在 std中查找时，编译器找到了string的输出运算符函数。查找规则的这个例外允许概念上作为类接口一部分的非成员函数无须单独的using声明就能被程序使用。