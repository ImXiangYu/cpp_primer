# 模板与泛型编程

模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。**这种转换发生在编译时。**

## 16.1.1 函数模板

我们可以定义一个通用的函数模板(function template)，而不是为每个类型都定义一个新函数，一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本

```cpp
template <typename T>
int compare(const T& a, const T& b) {
    if (a > b) return 1;
    else if (a < b) return -1;
    else return 0;
}
```

模板定义以关键字template开始，后跟一个**模板参数列表(template parameter list)**，这是一个逗号分隔的，一个或多个**模板参数(template parameter)**的列表，用小于号和大于号包围起来

**在模板定义中，模板参数列表不能为空**

模板参数列表的作用很像函数参数列表，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式或显式地）指定**模板实参(template argument)**，将其绑定到模板参数上

我们的compare函数声明了一个名为T的类型参数，在compare中，我们用名字T表示一个类型，而T表示的实际类型则在编译时根据compare的使用情况来确定

### 实例化模板函数

当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。编译器用推断出的模板参数来为我们**实例化(instantiate)**一个特定版本的函数，当编译器实例化一个模板时，它用实际的模板实参代替对应的模板参数来创建模板的一个新“实例”

对于这些编译器生成的版本，通常被称为模板的实例(instantiation)

### 模板类型参数

我们的compare函数有一个模板**类型参数(type parameter)**，一般来说，可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于声明变量或类型转换

```cpp
template <typename T>
T foo(T* a) {
    T tmp = *a;
    return tmp;
}
```

**类型参数前必须使用关键字class或typename，在模板参数列表中这两个关键字含义相同，可以互换使用，保留class是因为模板是在typename之前引入的，为了保持向前兼容性**

### 非类型模板参数

除了定义类型参数，还可以在模板中定义**非类型参数(nontype parameter)**。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。

```cpp
// 非类型参数(nontype parameter)
template <unsigned N, unsigned M>
int compare_nontype(const char (&p1)[N], const char (&p2)[M]) {
    return strcmp(p1, p2);
}
```

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。

**非类型模板参数的模板实参必须是常量表达式**

### inline和constexpr的函数模板

函数模板可以声明为inline或constexpr，如同非模板函数一样，可以放在模板参数列表之后，返回类型之前

```cpp
// 可以使用inline或constexpr
template <typename T>
inline T foo_inline(T a) {
    return a;
}
```

**模板程序应该尽量减少对实参类型的要求**

### 模板编译

当编译器遇到一个模板定义时，它并不生成代码，只有当我们实例化出模板的一个特定版本是，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用
一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数
的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

**函数模板和类模板成员函数的定义通常放在头文件中。**

### 大多数编译错误在实例化期间报告

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。

第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。

第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。

第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

```cpp
template <typename T>
T foo_string(T a) {
    return "hello"; // 如果传int返回string会怎么样？
    // error: invalid conversion from 'const char*' to 'int'
    // 已老实
}
```

如上例，直到实例化时才能发现问题

