# 3.1 命名空间的using声明

## 头文件不应包含using声明

头文件不应包含using声明，因为头文件的内容会被拷贝到所有引用它的文件中，一不小心就容易出现冲突

## 直接初始化和拷贝初始化

使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右边的值拷贝到新创建的对象中。与之相反，如果使用括号而不是等号，则执行的是直接初始化

# 3.2.2 string对象上的操作

## getline

可以使用getline替代>>，这样得到的字符串会保留输入时的空白符，函数接收一个输入流和一个string对象，会从输入流中读入内容，直到遇到换行符位置（换行符也被包含在内），然后把读取内容存入string（但不存换行符）。

**getline一遇到换行符就会结束读取并返回结果，哪怕一开始就是换行符也一样**

## size_type

line.size()返回的类型是string::size_type，是一个无符号整型数，因此使用时要注意，不要与int混用

## string的比较

按照字典序，有两条比较规则

1. 如果长度不同，但字符都相同，则字符串短的就小
2. 如果某些字符不同，则比较的是第一对不相同的字符

## 练习

### 练习3.3

请说明string类的输入运算符和getline函数分别是如何处理空白字符的。

- 类似 is >> s 的读取，string对象会忽略开头的空白并从第一个真正的字符开始，直到遇见下一空白为止。
- 类似 getline(is, s) 的读取，string对象会从输入流中读取字符，直到遇见换行符为止。（换行符也会被读取，但是不会出现在s中）

# 3.2.3 处理string中的字符

## isxxx(c)

![cctype](D:\cpp_primer\ch3\cctype.png)

**cctype头文件和ctype.h头文件内容是一样的，只不过命名规范符合C++的要求**

## range for

C++11加的

```cpp
for (auto c : str) {
	cout << c << endl;
}
```

**如果要改变元素的值，应该把循环变量定义成引用类型**

```cpp
for (auto &c : str) {
	c = toupper(c);
}
```

# 3.3 vector

## vector

vector是一个类模板，编译器根据模板创建类或者函数的过程称为实例化，对于类模板来说，我们通过提供额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息则由模板决定。

**提供信息的方式为：在模板名字后边跟一对尖括号，在括号内放上信息**

```cpp
vector<int> ivec;
vector<vector<string>> file;
```

## 定义和初始化vector对象

可以创建指定数量的元素，例如：
```cpp
vector<int> ivec(10, -1); // 10个int类型的元素，每个都是-1
```

## 定义vector大小？

**定义vector对象时，设定其大小可能会使性能更差，所以不必在创建时顺便指定容量**

# 3.3.3 其他vector操作

## vector比较大小

和string的类似：

1. 容量不同，但对应位置元素值相同时，元素少的更小
2. 值有区别，则由第一对不同的元素值的大小来决定

## 只能对已存在的元素执行下标操作

这里是个大坑点，不能用索引给vector和string添加元素，只能对确知已存在的元素执行下标操作不然会出现buffer overflow

**确保下标合法的一种有效手段就是尽可能使用range for**

# 3.4.1 迭代器

## begin和end

v.begin()，begin是指向第一个元素的迭代器，而end()，返回的是指向容器**尾元素的下一个位置**的迭代器，指示的是一个本不存在的**尾后**元素，这样的迭代器仅仅是个标志而已，没有什么实际意义。end成员返回的迭代器一般称为**尾后迭代器或尾迭代器**

如果容器为空，则begin和end返回同一个迭代器，都是尾后迭代器

一般情况下，我们不在意迭代器的准确类型是什么，因此一般使用auto定义

## 迭代器的用法

![iter](D:\cpp_primer\ch3\iter.png)

## 泛型编程

一般使用迭代器喜欢使用 it != v.end()，原因是标准库容器的迭代器大多都定义了!=而没有定义<运算符，所以一般喜欢使用!=而不是小于。

只要养成使用迭代器和!=的习惯，就不用太在意使用的是哪种容器

## const_iterator

const_iterator只能读取而不能修改其所指的元素值，如果对象是常量，使用begin和end就会返回const_iterator，例如：
```cpp
const vector<int> cv;
auto it1 = cv.begin(); // 此时的类型是vector<int>::const_iterator
```

C++11引入了两个新函数，分别是cbegin和cend，不论vector对象是否为const，都返回const_iterator

## 结合 解引用和成员访问 操作

要检查it所指字符串是否为空

```cpp
(*it).empty() // 这里的括号必不可少
```

先对it解引用，然后执行点运算符，如果不加圆括号，则点运算符由it来执行，会出错

## 箭头运算符

C++定义了箭头运算符(->)，目的就是为了把**解引用和成员访问两个操作结合**在一起

```cpp
it->mem
(*it).mem
```

二者表达的意思相同

# 3.5 数组

## 数组与vector

数组大小确定不变，但对于某些应用来说性能更好

**不确定元素的确切个数，建议使用vector**

# 3.5.1 定义和初始化内置数组

## 声明

a[d]，a是数组的名字，d是维度，维度必须是一个常量表达式

**常量表达式的必要条件**
根据C++标准，常量表达式需满足：

- **值在编译期完全确定**（如字面量、`constexpr` 函数结果）。
- **不依赖运行时数据**（如函数参数、用户输入）。
- 仅包含编译期可计算的操作，如算术运算、sizeof

## 显式初始化

如果使用列表初始化，则可以忽略数组的维度，而且会根据初始值的数量计算并推测

```cpp
int a1[] = {0, 1, 2}; //维度是3的数组
int a2[5] = {0, 1, 2}; // 等价于a2[] = {0, 1, 2, 0, 0}
```

## 字符数组

使用字符串字面值对字符数组进行初始化时要注意，字符串字面值的结尾处还有一个空字符，注意要留空字符的空间

```cpp
const char a1[3] = "wow" // 错误，没有空间存放空字符
```

## 不允许拷贝和赋值

不允许把数组的内容拷贝给另一个数组，也不允许使用数组为其他数组赋值

## 数组声明的含义

从数组的名字开始，从内向外顺序阅读

# 3.5.2 访问数组元素

## size_t

访问数组下标时，通常将其定义成size_t类型，这是一种机器相关的无符号类型，被设计的足够大以便表示内存中任意对象的大小，定义在cstddef头文件中，是stddef.h的C++版本

# 3.5.3 指针和数组

使用数组时，编译器一般会把它转换为指针

且在很多用到数组名字的地方，编译器会自动将其替换为一个指向数组首元素的指针

```cpp
string *p2 = nums; // 等价于p2 = &nums[0]
```

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

也就是说，当一个数组作为一个auto变量的初始值时，其推断得到的类型其实是指针而非数组

但当使用decltype关键字时，返回的类型仍然是数组而不是指针，转换不会发生

## 数组的尾元素

```cpp
int arr[10];
int *e = &arr[10];
```

这里的下标运算符索引到了一个不存在的元素，这个不存在的元素的唯一作用时提供其地址用于初始化e，就像尾迭代器一样，**不能对尾后指针执行解引用或递增**

## begin和end

C++11引入了begin和end，但数组不是类，这两个函数不是成员函数，因此需要把数组作为参数传入

```cpp
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
```

## 指针运算

给指针加上或减去某整数值，结果仍然是指针，新指针指向的元素与原来的指针相比，**前进（后退）了该整数值个位置**

## 指针的比较

只要两个指针指向同一个数组的元素，就能利用关系运算符对其进行比较，如果分别指向不相关的对象，则不能比较它们

## 内置的下标运算符

可以对指向数组元素的指针使用下标，但是是下标运算

```cpp
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于*(p+1)，就是ia[3]表示的元素
int k = p[-2]; // p[-2]是ia[0]表示的元素
```

内置的下标运算符索引值不是无符号类型，vector与string不支持负数下标

# 3.5.4 C风格字符串

**最好不要在C++程序中使用C风格字符串**

C风格字符串是把书写的字符串存放在字符数组中，并以空字符结束，意思是在字符串最后一个字符后面跟着一个空字符（'\0'）

# 3.5.5 与旧代码的接口

## string与C风格字符串

string提供了一个c_str的成员函数，返回值是一个C风格字符串，即返回一个指针，指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与string对象的一样。

指针的类型是const char*，确保我们不会改变字符数组的内容

```cpp
const char *str = s.c_str();
```

无法保证c_str返回的数组一直有效，比如改变s的值就有可能让之前返回的数组无法使用

因此如果想一直使用，最好重新拷贝一份

## vector与数组

不允许使用vector对象初始化数组，但允许使用数组初始化vector对象

```cpp
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```

也可以只拷贝一部分

```cpp
vector<int> subVec(int_arr + 1, int_arr + 4)
// 拷贝了int_arr[1], int_arr[2], int_arr[3]
```

## 尽量使用标准库类型

**现代C++程序应尽量使用vector和迭代器，避免使用内置数组和指针，尽量使用string，避免使用C风格的基于数组的字符串**

# 3.6 多维数组

多维数组其实是数组的数组

```cpp
int arr[10][20][30] = {0};
// 可以把所有元素初始化为0

int ia[3][4] = {
    {0, 1, 2, 3},
    {0, 1, 2, 3},
    {0, 1, 2, 3},
}
// 可以使用花括号如上初始化

int ia[3][4] = {0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3};
// 但是也可以使用这个更简洁的方式
```

## 使用range for处理多维数组

```cpp
size_t cnt = 0;
for (auto &row : ia){
	for(auto col : row) {
            col = cnt;
            ++cnt;
	}
}
```

**为什么要声明引用类型？**即使没有任何写操作，但是为了避免数组被自动转成指针，还是声明了引用类型，假设不适用引用类型，row将会被转换成指向该数组内首元素的指针，这样得到的row类型是int*，内层的循环将不合法

**因此，要使用range for处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型**

