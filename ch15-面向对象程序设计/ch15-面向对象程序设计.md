面向对象程序设计

## 15.1 OOP：概述

面向对象程序设计的核心思想是**数据抽象、继承和动态绑定**（封装、继承、多态）

通过数据抽象，我们可以将接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以一定程度上忽略相似类型的区别，以统一的方式使用它们的对象

### 继承

基类和派生类，基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

**虚函数**，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。**对于某些函数，基类希望派生类个自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)**

派生类要使用类派生列表，指出继承了哪个基类

```cpp
class Bulk_quote : public Quote {
public:
	double net_price(std::size_t) const override;
};
```

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以选择在这样的**函数之前加virtual**，也可以选择在**函数形参列表后加override**显式注明它将使用哪个成员函数改写基类的虚函数

### 动态绑定

**动态绑定又被称为运行时绑定**，函数的运行版本由实参决定，在运行时选择函数的版本，传基类调用基类，传派生类调用派生类

在C++中，当我们使用基类的引用（或指针）调用一个虚函数时，将发生动态绑定

## 15.2 定义基类和派生类

### 虚析构函数

作为继承关系中的跟节点的类通常都会定义一个虚析构函数

**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此**

### 成员函数与继承

派生类可以继承其基类的成员，但是对于虚函数必须重新对其定义，即派生类要对这些操作进行新定义以覆盖(override)从基类继承来的旧定义

在C++中，基类必须将它的两种成员函数区分开，一种是基类希望派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类将其定义为虚函数(virtual)。

当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能直接某个派生类的版本

任何构造函数之外的非静态函数都可以是虚函数，但virtual只能用于函数内部的声明语句，而不能用于类外部的函数定义，**如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数**

**成员函数如果没有被声明成虚函数，则其解析过程发生在编译时而非运行时**

### 访问控制与继承

派生类可以继承，却不一定有权访问从基类继承来的成员，派生类能访问public，但是不能访问private。但可以使用protected，使得派生类可以访问，但其他用户不能访问

## 15.2.2 定义派生类

派生类要使用类派生列表，指出继承了哪个基类。类派生列表的形式是一个冒号，后边紧跟以逗号分隔的基类列表，每个基类前面可以有public，private，protected三个访问说明符中的一个

```cpp
class Bulk_quote : public Quote {
public:
	double net_price(std::size_t) const override;
};
```

大多数类都只继承自一个类，被称作单继承，但是可以继承多个基类

### 派生类中的虚函数

派生类经常覆盖(override)它继承的虚函数，如果不该则，则会直接继承其在基类中的版本

派生类可以使用virtual，可以使用override来表明覆盖了基类的函数。
override要加在形参列表后面、const成员函数的const后面、或者引用成员函数的引用限定符

### 派生类对象及派生类向基类的类型转换

一个派生类包含自己的成员，也包含继承来的基类的成员。因为在派生类中含有与基类对应的组成部分，**因此我们可以把派生类的对象当作基类对象来使用，而且也可以将基类的指针或引用绑定到派生类对象的基类部分上**

这种转换称为**派生类到基类的(derived-to-base)**类型转换，编译器会隐式执行派生类到基类的转换

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用，用在需要基类引用的地方；也可以把派生类对象的指针用在需要基类指针的地方

### 每个类控制它自己的初始化过程

尽管派生类含有从基类继承来的成员，但是派生类不能直接初始化它们，**派生类必须用基类的构造函数来初始化它的基类部分**

派生类构造函数通过构造函数初始化列表将实参传递给基类构造函数

```cpp
Bulk_quote(const std::string& book, double p,
         	  std::size_t qty, double disc) :
		Quote(book, p), min_qty(qty), discount(disc) {	}
```

派生类的构造函数将两个参数传递给基类的构造函数，当基类的构造函数体结束后，我们构建的对象的基类部分也就完成初始化了，接下来会初始化派生类的成员。

**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员**

### 遵循基类的接口

每个类负责定义各自的接口，想要与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。

因此基类对象不能直接初始化基类的成员，而是调用基类的构造函数来初始化，尽管我们可以直接对其成员进行赋值

### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，无论从基类中派生出多少个派生类，对于每个静态成员来说都是只存在唯一的实例

### 派生类的声明

派生类的声明不需要包含派生列表

```cpp
class Bulk_quote : public Quote; // 错误，派生列表不应该出现在声明这里
class Bulk_quote; // 正确，声明派生类的正确方式
```

声明不需要包含这些细节，细节在定义时出现

### 被用作基类的类

如果想将某个类用作基类，则类必须已经定义而非仅声明，因为派生类中包含并且可以使用从基类继承来的成员，为了使用这些成员，派生类需要知道它们是什么。

因此，类不能派生它本身

### 防止继承的发生

如果不希望类被继承，则可以在类名后跟一个关键字final

```cpp
class NoDerived final {	};
```

## 15.2.3 类型转换与继承

**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在**

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上。例如，我们可以用Quote&指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给一个Quote*。

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：**当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。**

### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或表达式的**静态类型(static type)**与该表达式表示对象的**动态类型(dynamic type)**区分开

表达式的静态类型在**编译时总是已知的**，他是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，**直到运行时才可知**

静态类型是基类，动态类型可以是传递的派生类，此时静态类型与动态类型就不一致。**因此基类的指针或引用的静态类型可能与其动态类型不一致**

### 不存在从基类向派生类的隐式类型转换

派生类可以向基类进行类型转换是因为派生类对象都包含一个基类部分。

一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在

但是基类对象不能向派生类对象转换，因为基类中不包含派生类定义的成员，如果进行转换的话，可能会用访问到基类中不存在但派生类中存在的成员

**即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类到派生类的转换**，编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法

### 在对象间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换

当我们将派生类对象转换成基类类型时，会按值拷贝，派生类对象中非基类的部分（即派生类自己定义的部分）将会被切掉(sliced down)，即发生了**对象切片（object slicing）**

**当我们使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉**

### 具有继承关系的类之间发生的类型转换

想要理解在具有继承关系的类之间发生的类型转换，有三点非常重要：

- 从派生类向基类的类型转换只对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制函数。因此我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过这种操作只能处理派生类对象的基类部分

## 15.3 虚函数

当我们使用基类的引用或者指针调用一个虚函数成员时才会执行动态绑定，因为我们直到运行时才知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。

**我们必须为每个虚函数都提供定义，而不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数**

### 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数，被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个

**动态绑定只有当我们通过指针或引用调用虚函数时才能发生**，当我们通过普通类型的表达式调用虚函数时，编译时就会把调用的版本确定下来

### C++的多态性

在C++中，多态（Polymorphism）是一个核心概念，它允许以一个通用的方式处理不同类型的对象。通过多态性，可以实现运行时绑定（动态绑定），即根据对象的实际类型调用相应的方法，而不是根据引用或指针的类型来决定。这种机制极大地增强了程序的灵活性和可扩展性。

C++中的多态主要通过以下两种方式实现：

1. **编译时多态（静态多态）**：这通常指的是函数重载和运算符重载。在这种情况下，调用哪个函数或运算符是在编译阶段就确定下来的。

2. **运行时多态（动态多态）**：这是通过使用虚函数（virtual functions）实现的。当一个基类的指针或引用指向派生类的对象，并且通过该指针或引用调用了虚函数时，实际被调用的函数是根据对象的实际类型来决定的，而不是指针或引用的类型。这就允许我们编写能够基于对象类型的不同而表现出不同行为的代码。

为了使用运行时多态，必须满足以下几个条件：
- 基类中定义了至少一个虚函数。
- 使用基类的指针或引用来指向派生类的对象。
- 通过这个指针或引用调用虚函数。

下面是一个简单的例子说明如何使用虚函数实现多态：

```cpp
class Base {
public:
    virtual void show() { // 虚函数
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 覆盖基类的虚函数
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;
    basePtr = &derivedObj; // 基类指针指向派生类对象
    basePtr->show(); // 如果是运行时多态，这里会输出 "Derived class"
    
    return 0;
}
```

在这个例子中，`basePtr->show();` 这行代码会根据 `basePtr` 实际指向的对象类型（在这里是 `Derived` 类型）调用相应的 `show` 方法，展示了运行时多态的基本原理。

### 派生类中的虚函数

一个派生类的函数如果覆盖了继承而来的虚函数，则**它的形参类型必须与被它覆盖的基类函数完全一致**

**派生类的虚函数的返回类型也必须与基类函数匹配**，但当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。

如果D由B派生得到，则基类的虚函数可以返回`B*`而派生类的对应函数可以返回`D*`，只不过这样的返回类型要求D到B的类型转换是可访问的

### 虚函数与默认实参

虚函数也可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。

**如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致**

### 回避虚函数的机制

如果我们希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本，我们可以用作用域运算符来实现

```cpp
double undiscounted = baseP->Quote::net_price(42);
```

**该调用将在编译时完成解析**

通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

**如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。**

## 15.4 抽象基类

### 纯虚函数

当我们想要告诉用户函数是没有实际意义的，与普通的虚函数不一样，我们可以将其定义成纯虚(pure virtual)函数。只需要让声明语句=0即可

```cpp
double net_price(std::size_t) const = 0;
```

### 含有纯虚函数的类是抽象基类

含有纯虚函数的类是抽象基类，抽象基类负责定义接口，而后续的其他类可以继承该接口。
**我们不能直接创建一个抽象基类的对象**，必须要定义派生类对象且要覆盖定义的纯虚函数。

### 派生类构造函数只初始化它的直接基类

只需要初始化时先初始化自己继承的基类即可，无需考虑基类的基类，因为此时基类也会初始化它的基类，相当于向上传递

## 15.5 访问控制与继承

protected：

- 受保护的成员对类的用户来说是不可访问的
- 受保护的成员对派生类的成员和友元来说是可访问的
- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象的受保护成员没有任何访问权限

### 类的公有、私有和受保护继承

派生类的派生列表中的访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限

对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关

### 派生类向基类转换的可访问性

对于代码中某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的，反之则不行

### 友元不能被继承

不能继承友元关系，每个类负责控制各自成员的访问权限

### 改变个别成员的可访问性

```cpp
class Derived : private Base {
//注意: private 继承
public:
//保持对象尺寸相关的成员的访问级别
	using Base::size;
protected:
	using Base::n;
};
```

使用using改变可访问性，改变后，Derived的用户将可以使用size成员，而Derived的派生类将能使用n

**派生类只能为那些它可以访问的名字提供using声明**

### 默认的继承保护级别

struct和class的唯一区别就是默认成员访问说明符和默认派生访问说明符不同

struct默认public继承，class默认private继承

## 15.6 继承中的类作用域

每个类定义自已的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

### 名字查找先于类型检查

如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。

和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉

**因此，除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字**

### 使用using声明解决派生类中重载函数的“隐藏问题”

🔍 **核心问题：函数隐藏（Function Hiding）**

在 C++ 中，如果派生类定义了一个与基类同名的函数（即使参数不同），**基类中所有同名的重载函数都会被隐藏**，哪怕派生类只覆盖其中一个版本。

这会导致你无法调用基类的其他重载版本，即使你想用。

✅ **解决方案：使用 `using` 声明**

通过在派生类中使用 `using Base::func;`，可以把基类中名为 `func` 的**所有重载版本**都引入派生类作用域，这样就不会被隐藏了。之后你只需覆盖你真正需要修改的版本，其他版本自动可用。

📌 **总结要点**

- 成员函数（包括虚函数）可以被重载。
- 派生类中定义同名函数会**隐藏**基类所有同名重载函数。
- 使用 `using 基类名::函数名;` 可将基类的所有重载版本引入派生类作用域。
- 派生类只需覆盖自己需要修改的版本，其他版本自动继承可用。
- 这样避免了“必须覆盖所有重载版本”的繁琐操作。

✅ **示例代码**

```cpp
#include <iostream>
#include <string>
using namespace std;

// 基类
class Base {
public:
    virtual void print(int x) {
        cout << "Base::print(int): " << x << endl;
    }

    virtual void print(double x) {
        cout << "Base::print(double): " << x << endl;
    }

    virtual void print(const string& s) {
        cout << "Base::print(string): " << s << endl;
    }
};

// 派生类
class Derived : public Base {
public:
    // 使用 using 声明，把 Base 中所有 print 的重载都引入
    using Base::print;

    // 只覆盖其中一个版本：处理 int 的 print
    void print(int x) override {
        cout << "Derived::print(int): " << x * 2 << endl;
    }

    // 注意：我们没有覆盖 print(double) 和 print(string)
    // 但由于 using 声明，它们仍然可以在 Derived 对象中调用
};

int main() {
    Derived d;

    d.print(5);           // 调用 Derived::print(int)
    d.print(3.14);        // 调用 Base::print(double) —— 通过 using 引入
    d.print("Hello");     // 调用 Base::print(string) —— 通过 using 引入

    return 0;
}
```

💡 输出结果

```
Derived::print(int): 10
Base::print(double): 3.14
Base::print(string): Hello
```

❗ 如果没有 `using Base::print;` 会怎样？

```cpp
class Derived : public Base {
public:
    void print(int x) override {
        cout << "Derived::print(int): " << x * 2 << endl;
    }
    // 没有 using 声明
};
```

此时：

```cpp
Derived d;
d.print(5);     // ✅ OK，调用 Derived::print(int)
d.print(3.14);  // ❌ 编译错误！Base::print(double) 被隐藏了
d.print("Hi");  // ❌ 编译错误！Base::print(string) 也被隐藏了
```

即使 `print(double)` 和 `print(string)` 没被覆盖，也无法调用，因为名字被“遮住了”。

**✅ 正确做法总结**

```cpp
class Derived : public Base {
public:
    using Base::print;  // 关键：引入所有重载版本

    void print(int x) override {
        cout << "Modified behavior for int\n";
    }
    // 其他版本自动可用
};
```

**✅ 结论**

使用 `using Base::func;` 是处理派生类中重载函数隐藏问题的标准、优雅的解决方案。它让你可以**有选择地覆盖部分重载函数**，而保留其他版本的可访问性。

## 15.7.1 虚析构函数

基类通常应该定义一个虚析构函数

当我们delete一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。

例如，如果我们delete一个Quote*类型的指针，则该指针有可能实际指向了一个Bulk_quote类型的对象。如果这样的话，编译器就必须清楚它应该执行的是Bulk _quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本

**如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为**

### 虚析构函数将阻止合成移动操作

如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作

**尽管 `=default` 让编译器生成默认实现，但“显式声明”这个行为本身就已经触发了规则。**

编译器看到你**显式声明**了析构函数（即使使用 `=default`），它就认为：“用户对析构函数有特殊关注，可能意味着类的资源管理比较复杂，我不能安全地自动生成移动操作。” 因此，编译器会保守地选择**不生成**移动构造函数和移动赋值运算符。

如果需要移动语义，必须**显式声明并定义（或 `=default`）移动操作**

```cpp
class B {
    std::string data;
public:
    ~B() = default;
    B(B&&) = default;            // 显式要求生成移动构造
    B& operator=(B&&) = default; // 显式要求生成移动赋值
};
```

## 15.7.3 派生类的拷贝控制成员

派生类构造函数在初始化阶段不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值

### 派生类析构函数

和构造函数以及赋值运算符不同，派生类析构函数只负责销毁由派生类自己分配的资源

对象销毁顺序和创建顺序相反：派生类析构函数首先执行，然后是基类析构函数，沿继承体系向上

## 15.7.4 继承的构造函数

派生类继承基类构造函数，虽然不是常规继承，但我们将其称为继承

方法就是提供一条注明了（直接）基类名的using声明语句

```cpp
class Bulk_quote : public Disc_quote (
public:
	using Disc_quote::Disc_quote; // 继承Disc_quote的构造函数
	double net_price(std::size_t) const;
};
```

### 继承的构造函数的特点

和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数：受保护的构造函数和公有构造函数也是同样的规则。

## 15.8 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式，因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器中

如果我们定义vector保存基类对象，则传入派生类对象时派生部分将会被切掉
如果保存派生类对象，则基类对象不能转为派生类对象

### 在容器中放置（智能）指针而非对象

当我们在容器中存放具有继承关系的对象时，实际上存放的通常是是基类的指针（最好是智能指针），这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型
