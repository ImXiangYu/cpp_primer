# 面向对象程序设计

## 15.1 OOP：概述

面向对象程序设计的核心思想是**数据抽象、继承和动态绑定**（封装、继承、多态）

通过数据抽象，我们可以将接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以一定程度上忽略相似类型的区别，以统一的方式使用它们的对象

### 继承

基类和派生类，基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

**虚函数**，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。**对于某些函数，基类希望派生类个自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)**

派生类要使用类派生列表，指出继承了哪个基类

```cpp
class Bulk_quote : public Quote {
public:
	double net_price(std::size_t) const override;
};
```

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以选择在这样的**函数之前加virtual**，也可以选择在**函数形参列表后加override**显式注明它将使用哪个成员函数改写基类的虚函数

### 动态绑定

**动态绑定又被称为运行时绑定**，函数的运行版本由实参决定，在运行时选择函数的版本，传基类调用基类，传派生类调用派生类

在C++中，当我们使用基类的引用（或指针）调用一个虚函数时，将发生动态绑定

## 15.2 定义基类和派生类

### 虚析构函数

作为继承关系中的跟节点的类通常都会定义一个虚析构函数

**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此**

### 成员函数与继承

派生类可以继承其基类的成员，但是对于虚函数必须重新对其定义，即派生类要对这些操作进行新定义以覆盖(override)从基类继承来的旧定义

在C++中，基类必须将它的两种成员函数区分开，一种是基类希望派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类将其定义为虚函数(virtual)。

当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能直接某个派生类的版本

任何构造函数之外的非静态函数都可以是虚函数，但virtual只能用于函数内部的声明语句，而不能用于类外部的函数定义，**如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数**

**成员函数如果没有被声明成虚函数，则其解析过程发生在编译时而非运行时**

### 访问控制与继承

派生类可以继承，却不一定有权访问从基类继承来的成员，派生类能访问public，但是不能访问private。但可以使用protected，使得派生类可以访问，但其他用户不能访问

## 15.2.2 定义派生类

派生类要使用类派生列表，指出继承了哪个基类。类派生列表的形式是一个冒号，后边紧跟以逗号分隔的基类列表，每个基类前面可以有public，private，protected三个访问说明符中的一个

```cpp
class Bulk_quote : public Quote {
public:
	double net_price(std::size_t) const override;
};
```

大多数类都只继承自一个类，被称作单继承，但是可以继承多个基类

### 派生类中的虚函数

派生类经常覆盖(override)它继承的虚函数，如果不该则，则会直接继承其在基类中的版本

派生类可以使用virtual，可以使用override来表明覆盖了基类的函数。
override要加在形参列表后面、const成员函数的const后面、或者引用成员函数的引用限定符

### 派生类对象及派生类向基类的类型转换

一个派生类包含自己的成员，也包含继承来的基类的成员。因为在派生类中含有与基类对应的组成部分，**因此我们可以把派生类的对象当作基类对象来使用，而且也可以将基类的指针或引用绑定到派生类对象的基类部分上**

这种转换称为**派生类到基类的(derived-to-base)**类型转换，编译器会隐式执行派生类到基类的转换

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用，用在需要基类引用的地方；也可以把派生类对象的指针用在需要基类指针的地方

### 每个类控制它自己的初始化过程

尽管派生类含有从基类继承来的成员，但是派生类不能直接初始化它们，**派生类必须用基类的构造函数来初始化它的基类部分**

派生类构造函数通过构造函数初始化列表将实参传递给基类构造函数

```cpp
Bulk_quote(const std::string& book, double p,
         	  std::size_t qty, double disc) :
		Quote(book, p), min_qty(qty), discount(disc) {	}
```

派生类的构造函数将两个参数传递给基类的构造函数，当基类的构造函数体结束后，我们构建的对象的基类部分也就完成初始化了，接下来会初始化派生类的成员。

**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员**

### 遵循基类的接口

每个类负责定义各自的接口，想要与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。

因此基类对象不能直接初始化基类的成员，而是调用基类的构造函数来初始化，尽管我们可以直接对其成员进行赋值

### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，无论从基类中派生出多少个派生类，对于每个静态成员来说都是只存在唯一的实例

### 派生类的声明

派生类的声明不需要包含派生列表

```cpp
class Bulk_quote : public Quote; // 错误，派生列表不应该出现在声明这里
class Bulk_quote; // 正确，声明派生类的正确方式
```

声明不需要包含这些细节，细节在定义时出现

### 被用作基类的类

如果想将某个类用作基类，则类必须已经定义而非仅声明，因为派生类中包含并且可以使用从基类继承来的成员，为了使用这些成员，派生类需要知道它们是什么。

因此，类不能派生它本身

### 防止继承的发生

如果不希望类被继承，则可以在类名后跟一个关键字final

```cpp
class NoDerived final {	};
```

## 15.2.3 类型转换与继承

**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在**

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上。例如，我们可以用Quote&指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给一个Quote*。

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：**当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。**

### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或表达式的**静态类型(static type)**与该表达式表示对象的**动态类型(dynamic type)**区分开

表达式的静态类型在**编译时总是已知的**，他是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，**直到运行时才可知**

静态类型是基类，动态类型可以是传递的派生类，此时静态类型与动态类型就不一致。**因此基类的指针或引用的静态类型可能与其动态类型不一致**

### 不存在从基类向派生类的隐式类型转换

派生类可以向基类进行类型转换是因为派生类对象都包含一个基类部分。

一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在

但是基类对象不能向派生类对象转换，因为基类中不包含派生类定义的成员，如果进行转换的话，可能会用访问到基类中不存在但派生类中存在的成员

**即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类到派生类的转换**，编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法

### 在对象间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换

当我们将派生类对象转换成基类类型时，会按值拷贝，派生类对象中非基类的部分（即派生类自己定义的部分）将会被切掉(sliced down)，即发生了**对象切片（object slicing）**

**当我们使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉**

### 具有继承关系的类之间发生的类型转换

想要理解在具有继承关系的类之间发生的类型转换，有三点非常重要：

- 从派生类向基类的类型转换只对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制函数。因此我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过这种操作只能处理派生类对象的基类部分

## 15.3 虚函数

当我们使用基类的引用或者指针调用一个虚函数成员时才会执行动态绑定，因为我们直到运行时才知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。

**我们必须为每个虚函数都提供定义，而不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数**

### 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数，被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个

**动态绑定只有当我们通过指针或引用调用虚函数时才能发生**，当我们通过普通类型的表达式调用虚函数时，编译时就会把调用的版本确定下来

### C++的多态性

在C++中，多态（Polymorphism）是一个核心概念，它允许以一个通用的方式处理不同类型的对象。通过多态性，可以实现运行时绑定（动态绑定），即根据对象的实际类型调用相应的方法，而不是根据引用或指针的类型来决定。这种机制极大地增强了程序的灵活性和可扩展性。

C++中的多态主要通过以下两种方式实现：

1. **编译时多态（静态多态）**：这通常指的是函数重载和运算符重载。在这种情况下，调用哪个函数或运算符是在编译阶段就确定下来的。

2. **运行时多态（动态多态）**：这是通过使用虚函数（virtual functions）实现的。当一个基类的指针或引用指向派生类的对象，并且通过该指针或引用调用了虚函数时，实际被调用的函数是根据对象的实际类型来决定的，而不是指针或引用的类型。这就允许我们编写能够基于对象类型的不同而表现出不同行为的代码。

为了使用运行时多态，必须满足以下几个条件：
- 基类中定义了至少一个虚函数。
- 使用基类的指针或引用来指向派生类的对象。
- 通过这个指针或引用调用虚函数。

下面是一个简单的例子说明如何使用虚函数实现多态：

```cpp
class Base {
public:
    virtual void show() { // 虚函数
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 覆盖基类的虚函数
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;
    basePtr = &derivedObj; // 基类指针指向派生类对象
    basePtr->show(); // 如果是运行时多态，这里会输出 "Derived class"
    
    return 0;
}
```

在这个例子中，`basePtr->show();` 这行代码会根据 `basePtr` 实际指向的对象类型（在这里是 `Derived` 类型）调用相应的 `show` 方法，展示了运行时多态的基本原理。

### 派生类中的虚函数

一个派生类的函数如果覆盖了继承而来的虚函数，则**它的形参类型必须与被它覆盖的基类函数完全一致**

**派生类的虚函数的返回类型也必须与基类函数匹配**，但当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。

如果D由B派生得到，则基类的虚函数可以返回`B*`而派生类的对应函数可以返回`D*`，只不过这样的返回类型要求D到B的类型转换是可访问的

### 虚函数与默认实参

虚函数也可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。

**如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致**

### 回避虚函数的机制

如果我们希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本，我们可以用作用域运算符来实现

```cpp
double undiscounted = baseP->Quote::net_price(42);
```

**该调用将在编译时完成解析**

通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

**如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。**

