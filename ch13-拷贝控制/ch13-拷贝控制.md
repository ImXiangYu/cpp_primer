# 拷贝控制

一个类通过定义五种特殊的成员函数来控制【拷贝、移动、赋值和销毁】时做什么，即:

1. 拷贝构造函数(copy constructor)
2. 拷贝赋值运算符（copy-assignment operator)
3. 移动构造函数(move constructor)
4. 移动赋值运算符（move-assignment operator)
5. 析构函数（destructor)

**在定义任何C++类时，拷贝控制操作都是必要部分，如果不显式定义，编译器定义的版本的行为往往出乎意料**

## 13.1.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数

```cpp
class Foo {
public:
	Foo(); // 默认构造函数
	Foo(const Foo&); // 拷贝构造函数
}
```

当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。

当我们使用拷贝初始化（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

**拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的**

### 拷贝初始化发生的情况

1. 使用=定义变量时
2. 将一个对象作为实参传递给一个非引用类型的形参（传值）
3. 从一个返回类型为非引用类型的函数返回一个对象
4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

## 13.1.2 拷贝赋值运算符

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，则编译器会合成一个

拷贝赋值运算符实际上就是个名为operator=的函数，即运算符重载

```cpp
class Foo {
public:
	Foo& operator=(const Foo&); // 赋值运算符
}
```

**赋值运算符通常应该返回一个指向其左侧运算对象的引用**

```cpp
//等价于合成拷贝赋值运算符
Sales_data&
Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo; 	//调用string::operator=
    units_sold = rhs.units_sold;	//使用内置的int赋值
    revenue = rhs.revenue;	//使用内置的double赋值
    return *this;	//返回一个此对象的引用
}
```

 等价于默认合成的拷贝赋值运算符

## 13.1.3 析构函数

析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数

```cpp
class Foo {
public:
	~Foo(); // 析构函数
}
```

在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

### 什么时候会调用析构函数？

无论何时一个对象被销毁，就会自动调用其析构函数：

1. 变量在离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
4. 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
5. 对于临时对象，当创建它的完整表达式结束时被销毁

由于析构函数自动执行，因此程序可以按需分配资源，无需担心何时释放

### 合成析构函数

如果不是被用来阻止该类型的对象被销毁的，则合成析构函数的函数体为空
编译器默认合成的析构函数

```cpp
class Foo {
public:
	~Foo() {  }; // 成员会被自动销毁，除此之外不需要做其他事情 
}
```

等价于合成析构函数，只需要函数体为空即可

**析构函数体自身并不直接销毁成员，成员是在析构函数体之外隐含的析构阶段中被销毁的**

## 13.1.4 三/五法则

1. 拷贝构造函数(copy constructor)

2. 拷贝赋值运算符（copy-assignment operator)

3. 析构函数（destructor)

   

4. 移动构造函数(move constructor)

5. 移动赋值运算符（move-assignment operator)

C++并不要求我们定义所有这些操作，可以只定义其中的一个或两个，但这些操作通常应该被看作一个整体，通常只需要其中一个操作而不需要定义所有操作的情况是很少见的

### 需要析构函数的类也需要拷贝和赋值操作

对析构函数的需求比拷贝构造或赋值的需求更为明显，如果这个类需要一个析构函数，则几乎肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符

### 需要拷贝操作的类也需要赋值操作，反之亦然

如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。

然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

### 定义了任何一个拷贝操作，就应该定义所有五个操作

某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作，这些类通常拥有一个资源，而拷贝成员必须拷贝此资源，一般来说，拷贝资源会导致额外开销，因此在非必要情况下，定义移动构造函数和移动赋值运算符的类可以避免此问题

## 13.1.5 使用=default

可以定义=default显示要求编译器生成合成的版本

```cpp
class Sales_data {
public:
    //拷贝控制成员；使用default
    Sales_data() = default;
    Sales_data (const Sales_data&) = default;
    Sales_data& operator=(const Sales_data&);
    ~Sales_data () = default;
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

当我们在类内使用=default时，合成的函数将隐式声明为内联，如果不希望时内联，则应该对成员的类外定义使用=default

## 13.1.6 阻止拷贝

**大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式还是显示**

我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(deleted function)

```cpp
struct NoCopy {
	NoCopy() = default;	//使用合成的默认构造函数
	NoCopy(const NoCopy&) = delete;	//阻止拷贝
	NoCopy &operator=(const NoCopy&) = delete;	//阻止赋值
	~NoCopy() = default; //使用合成的析构函数
}
```

=delete通知编译器和代码的读者，我们不希望定义这些成员

与=default不同，=delete必须出现在函数第一次声明的时候，同时可以对任何函数指定=delete（只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）

### 不应该删除析构函数

我们不应该删除析构函数，对于一个删除了析构函数的类型，我们不能定义该类型的变量或临时对象，该成员无法被销毁。

虽然对于删除了析构函数的类型，我们不能定义这种类型的变量或成员，但是可以动态分配这种类型的对象，**不能释放**

```cpp
struct NoDtor {
	NoDtor(）= default; 	//使用合成默认构造函数
	~NoDtor()）= delete;	//我们不能销毁NoDtor类型的对象
}
NoDtor nd;	//错误：NoDtor的析构函数是删除的
NoDtor *p = new NoDtor();	// 正确:但我们不能 delete p
delete p;	//错误：NoDtor的析构函数是删除的
```

### 合成的拷贝控制成员可能是删除的

对于某些类来说，编译器可能将合成的成员定义为删除的函数

- 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的)，则类的合成析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函
  数被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

**本质上：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的**

## 13.2 拷贝控制和资源管理

一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。

为了定义这些成员，我们首先必须确定此类型对象的拷贝语义，可以定义拷贝操作，使类的行为看起来像一个值或像一个指针

类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。

行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

## 13.2.1 行为像值的类

为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝，为了实现类值行为，一个类需要：

1. 定义一个拷贝构造函数，完成拷贝而不是拷贝指针
2. 定义一个析构函数来释放资源
3. 定义一个拷贝赋值运算符来释放对象当前的资源，并从右侧运算对象拷贝

### 类值拷贝复制运算符

我们需要编写一个异常安全的赋值运算符，当异常发生时，能将左侧运算对象置于一个有意义的状态

```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs) {
    auto newp = new string(*rhs.ps); // 拷贝底层 string
    delete ps; //释放旧内存
    ps = newp; //从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this; //返回本对象
}
```

通过先拷贝右侧运算对象，我们可以处理自赋值的情况，能保证在异常发生时代码也是安全的，在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的string

**当你编写赋值运算符时，有两点需要记住：**

- 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

## 13.2.2 定义行为像指针的类

对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。我们的类仍然需要自已的析构函数来释放接受string参数的构造函数分配的内存

令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。拷贝（或赋值）一个shared_ptr会拷贝（赋值）shared_ptr所指向的指针。shared_ptr类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，shared_ptr类负责释放资源。

但是，有时我们希望直接管理资源。在这种情况下，使用引用计数(reference count)就很有用了。为了说明引用计数如何工作，我们将重新定义HasPtr，令其行为像指针一样，但我们不使用shared_ptr，而是设计自己的引用计数。

### 引用计数

引用计数的工作方式如下：

- 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。
- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。

我们可以将计数器保存在动态内存中，当创建一个对象时，我们分配一个新的计数器，当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和元对象都会指向相同的计数器

```cpp
class HasPtr {
public:
	//构造函数分配新的string和新的计数器，将计数器置为1
	HasPtr(const std::string &s = std::string ()):
		ps(new std::string(s)), i(0), use(new std::size_t(1)) { }
	//拷贝构造函数拷贝所有三个数据成员，并递增计数器
	HasPtr(const HasPtr &p):
		ps(p.ps), i(p.i), use(p.use) ( ++*use; }
	HasPtr& operator=(const HasPtr&);
	~HasPtr();
private:
	std::string* ps;
	int i;
	std::size_t* use; // 用来记录有多少个对象共享*ps的成员
}
```

```cpp
HasPtr::~HasPtr(){
	if (--*use == 0) { 	// 如果引用计数变为0
            delete ps;	// 释放string内存
            delete use;	// 释放计数器内存
	}
}
```

```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs) {
	++*rhs.use;	// 递增右侧运算对象的引用计数
	if (--*use == 0) {	// 然后递减本对象的引用计数
		delete ps;	// 如果没有其他用户
		delete use;	// 释放本对象分配的成员
	}
	ps = rhs.ps;	// 将数据从rhs拷贝到本对象
	i = rhs.i;
	use = rhs.use;
	return *this;	// 返回本对象
}
```

## 13.3 交换操作

我们可以定义一个直接交换指针的swap，避免内存分配

```cpp
class HasPtr {
	friend void swap(HasPtr&, HasPtr&);
};
inline void swap(HasPtr &lhs, HasPtr &rhs) {
	using std::swap;
	swap(lhs.ps, rhs.ps);	// 交换指针，而不是string数据
	swap(lhs.i, rhs.i);		// 交换int成员
}
```

如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本。
因此，如果存在类型特定的swap，swap调用会与之匹配，如果不存在类型特定的版本，则会使用std中的版本（假定作用域中有using声明）

### 在赋值运算符中使用swap

运算符使用了一种名为**拷贝并交换（copy and swap）**的技术，可以将左侧运算对象与右侧运算对象的一个副本进行交换

```cpp
// 注意rhs是按值传递的，意味着HasPtr的
// 拷贝构造函数将右侧运算对象中的string拷贝到rhs
HasPtr& HasPtr::operator=(HasPtr rhs) {
	//交换左侧运算对象和局部变量rhs的内容
	swap(*this, rhs);	//rhs现在指向本对象曾经使用的内存
	return *this;	//rhs被销毁，从而delete了rhs中的指针
}
```

在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr的操作会分配该对象的string的一个新副本。

当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，即释放掉左侧运算对象中原来的内存

**使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值**

## 13.6 对象移动

在很多情况下都会发生对象拷贝，某些情况下，对象拷贝后就立即被销毁了，如果我们能移动而非拷贝对象，避免分配和释放的额外开销，则会大幅提升性能

我们可以用容器保存不可拷贝的类型，只要它们能够被移动即可

## 13.6.1 右值引用

右值引用（rvalue reference），所谓右值引用就是必须绑定到右值的引用。

通过&&而不是&来获取右值引用。

右值引用的一个重要性质是——只能绑定到一个将要销毁的对象，因此我们可以自由地将一个右值引用的资源“移动”到另一个对象中

一般而言，一个左值表达式表示的是一个对象的身份，右值表达式表示的是对象的值。类似任何引用，一个右值引用也不过是某个对象的另一个名字

对于常规引用（为了将其和右值引用区分开，我们可以将其称为左值引用），我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回右值的表达式
右值引用有着完全相反的绑定特性，我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上

### 左值持久，右值短暂

左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，我们得知：

1. 所引用的对象将要被销毁
2. 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源

### 变量是左值

```cpp
int &&rr1 = 42; // 正确，字面常量是右值
int &&rr2 = rr1; // 错误，表达式rr1是左值
```

变量是持久的，直到离开作用域时才被销毁。

变量是左值，因此我不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行

### 标准库move函数

虽然不能将一个右值引用直接绑定到一个左值上，但是可以显式地将一个左值转换为对应的右值引用，可以调用move来获得绑定到左值上的右值引用

```cpp
int &&rr3 = std::move(rr1); // ok
```

move调用告诉编译器：我们有一个左值，但我希望像一个右值一样处理它，这就意味着承诺：除了对rr1赋值或销毁它之外，我们将不再使用它，在调用move之后，我们不能对移后源对象做任何假设

**我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象**

**应该使用std::move而不是move，也不用using声明，这样做可以避免潜在的名字冲突**

## 13.6.2 移动构造函数和移动赋值运算符

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参

除了完成资源移动，移动构造函数还必须确保移后源对象处于销毁无害的状态。当资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象

```cpp
StrVec::StrVec(StrVec &&s) noexcept // 移动操作不应抛出任何异常
: elemens(s.elements), first_free(s.first_free), cap(s.cap)
// 成员初始化接管s中的资源
{
	s.elements = s.first_free = s.cap = nullptr;
	// 令s进入这样的状态——对其运行析构函数是安全的
}
```

**不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept**

使用noexcept是为了告诉标准库我们的移动构造函数可以安全使用，不会出现发生异常使得部分元素发生了移动而部分元素没有的情况

### 移动赋值运算符

移动赋值运算符必须正确处理自赋值

```cpp
StrVec &StrVec::operator=(StrVec &&rhs) noexcept {
    if (this != &rhs){
        // 直接检测自赋值
        free(); // 释放已有元素
        elements = rhs.elements; // 从rhs接管资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        // 将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

我们会检查this指针与rhs的地址是否相同，如果相同，则右侧和左侧运算对象指向相同的对象，我们不需要做任何事情。否则，我们释放左侧运算对象所使用的内存，并接管给定对象的内存。

为什么要检查自赋值呢？是因为这里的右值可能是move调用的返回结果

### 移后源对象必须可析构

在完成移动操作后，源对象会被销毁，因此必须确保移后源对象进入一个可析构的状态。

除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，对象有效就是指可以安全地为其赋予新值或者安全地使用，而不依赖于当前值

移动操作对于移后源对象中留下的值没有任何要求，因此程序不应该依赖于移后源对象中的数据

例如，当我们从一个标准库string或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对它执行诸如empty或size这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。

**在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设，即不能猜测其值是多少**

### 合成的移动操作

编译器合成移动操作的条件和合成拷贝操作的条件大不相同

如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，则编译器总会为我们合成这些操作，拷贝操作要不被定义为逐成员拷贝，要么被定义为对象赋值，要么被定义为删除的函数

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了

因此，某些类就没有移动构造函数或移动赋值运算符，如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作

**只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符**

如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员

```cpp
//编译器会为x和hasX合成移动操作
struct x {
	int i;	//内置类型可以移动
	std::string s;	//string定义了自己的移动操作
};
struct hasx {
	X mem;	//x有合成的移动操作
};
X x, x2 = std::move(x);	//使用合成的移动构造函数
hasX hx, hx2 = std::move (hx);	//使用合成的移动构造函数
```

与拷贝操作不同，**移动操作永远不会隐式定义为删除的函数**，但是如果我们显示要求编译器生成=default的移动操作，且编译器不能移动所有成员，此时编译器会将移动操作定义为删除的函数

什么时候将合成的移动操作定义为删除的函数？

- 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
- 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
- 类似拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算
  符被定义为删除的。

例如，假定Ｙ是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数：
```cpp
//假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数
struct hasY {
    hasY() = default;
    hasY (hasY&&) = default;
    Ymem;	//hasY将有一个删除的移动构造函数
};
hasY hy, hy2 = std::move(hy);	//错误：移动构造函数是删除的
```

编译器可以拷贝类型为Y的对象，但不能移动它们。类hasY显式地要求一个移动构造函数，但编译器无法为其生成。因此，hasY会有一个删除的移动构造函数。

### 移动操作和合成的拷贝控制成员

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

**定义了一个移动构造函数或移动赋值运算符的类必须也定义自已的拷贝操作。否则，这些成员默认地被定义为删除的。**

### 移动右值，拷贝左值

```cpp
StrVec vl, v2;
v1 = v2;				   //v2是左值，使用拷贝赋值
StrVec getVec(istream &);	 //getVec返回一个右值
v2 = getVec (cin);			//getVec(cin)是一个右值，使用移动赋值
// 因为这里返回的是值类型，返回一个对象而不是引用
// 是创建的临时对象，因此是右值
```

这里的两个赋值运算符都是可行的——将getVec的结果绑定到两个运算符的参数都是允许的，调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&&则是精确匹配，因此第二个赋值会使用移动赋值运算符

### 但如果没有移动构造函数，右值也被拷贝

如果一个类有一个拷贝构造函数但未定义移动构造函数，则编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数而没有移动构造函数。

如果一个类没有移动构造函数，则函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动它们时也是如此

```cpp
class Foo {
public:
	Foo () = default;
	Foo(constFoo&)；// 拷贝构造函数
	// 其他成员定义，但Foo未定义移动构造函数
};
Foo x;
Foo y(x);	// 拷贝构造函数；x是一个左值
Foo z(std::move(x));	// 拷贝构造函数，因为未定义移动构造函数
```

在对z进行初始化时，我们调用了move(x)，它返回一个绑定到x的Foo&&。Foo的拷贝构造函数是可行的，因为我们可以将一个Foo&&转换为一个const Foo&。因此，z的初始化将使用Foo的拷贝构造函数。

值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算符的情况类似）。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至都不会改变原对象的值。

**如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。**

### 拷贝并交换赋值运算符和移动操作

拷贝并交换赋值运算符：

```cpp
HasPtr& operator=(HasPtr rhs) { swap(*this, rhs); return *this; }
```

这个函数**本身不是移动赋值运算符**（移动赋值运算符的典型签名是 `operator=(HasPtr&& rhs)`）。它是一个**通用的赋值运算符**，通过**按值传递参数**，巧妙地将“复制数据”的责任**推迟**给了**拷贝构造函数或移动构造函数**。根据传入参数是左值还是右值，编译器会选择合适的构造函数来初始化 `rhs`，从而使得这个单一的赋值运算符能够**正确且高效地处理拷贝和移动两种场景**。这是 C++ 中一个非常优雅和实用的设计模式。

### 移动迭代器

移动迭代器（Move Iterator）是C++11引入的一个标准库工具，主要用于在不进行拷贝的情况下转移资源所有权。它通常用于将容器中的元素移动到另一个位置或容器中，而不是通过拷贝来实现这一过程。这可以提高性能，尤其是在处理大型对象或资源密集型对象时。

移动迭代器通过`std::make_move_iterator`函数创建，该函数接受一个普通迭代器，并返回一个移动迭代器。当使用移动迭代器对容器中的元素进行操作时，实际上是在对该元素的右值引用进行操作，这意味着你可以“移动”资源，而不是复制它们。

例如，在向一个容器中添加元素时，如果源容器中的元素支持移动构造（即定义了移动语义），那么使用移动迭代器可以避免不必要的拷贝，直接转移资源的所有权，从而可能显著提高效率。

这是一个简单的例子：

```cpp
#include <vector>
#include <iostream>
#include <iterator> // for std::make_move_iterator

int main() {
    std::vector<std::string> src = {"Hello", "world"};
    std::vector<std::string> dest;

    // 使用移动迭代器移动元素而不是复制
    dest.assign(std::make_move_iterator(src.begin()), std::make_move_iterator(src.end()));

    // 打印dest的内容，src中的内容可能被移动后不可用
    for (const auto& str : dest) {
        std::cout << str << " ";
    }
    std::cout << "\n";
}
```

在这个例子中，`src`中的字符串被移动到`dest`中，而不是被复制过去。因此，`src`中的元素在移动后可能会处于有效但未指定的状态，具体取决于移动语义的实现。

### 不要随意使用移动操作

由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。

通过在类代码中小心地使用move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。

**在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std::move。**

## 13.6.3 右值引用和成员函数

除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。

例如，定义了push_back的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。假定x是元素类型，那么这些容器就会定义以下两个push_back版本：
```cpp
void push_back(const X&) ; //拷贝：绑定到任意类型的x
void push_back(X&&); 	  //移动：只能绑定到类型x的可修改的右值
```

**区分拷贝和移动的重载函数通常有一个版本接受一个const T&，而另一个版本接受一个T&&**

调用的差别在于实参是一个左值还是右值

### 右值和左值引用成员函数

通常，我们在一个对象上调用成员函数，不管它是左值还是右值

```cpp
string s1 = "a value", s2 = "another"
auto n = (s1 + s2).find('a');

s1 + s2 = "wow!";
```

我们在string右值上调用了find成员，也对两个string的连接结果——一个右值进行了赋值

在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算对象（即，this指向的对象）是一个左值。

我们可以在参数列表后放一个**引用限定符（reference qualifier）**

```cpp
class MyClass {
public:
    // 成员函数foo只能由左值调用
    void foo() & {
        std::cout << "foo called for lvalue" << std::endl;
    }

    // 成员函数bar只能由右值调用
    void bar() && {
        std::cout << "bar called for rvalue" << std::endl;
    }
};

int main() {
    MyClass a;
    a.foo(); // 正确，因为a是左值
    a.bar(); // 错误，bar不能由左值调用
    
    MyClass().foo(); // 错误，foo不能由右值调用
    MyClass().bar(); // 正确，因为MyClass()是右值
    
    return 0;
}
```

在这个例子中，`foo`函数使用了左值引用限定符`&`，所以它只能被左值调用；而`bar`函数使用了右值引用限定符`&&`，所以它只能被右值调用。这样，就可以根据对象的状态（左值或右值）来限制哪些函数可以被调用，从而使得代码更加安全和意图明确。

### 重载和引用函数

引用限定符也可以区分重载版本：

```cpp
class Foo {
public:
	Foo sorted() &&; //可用于可改变的右值
	Foo sorted() const &; //可用于任何类型的Foo
	//Foo的其他成员的定义
private:
	vector<int> data;
};
//本对象为右值，因此可以原址排序
Foo Foo::sorted() && {
	sort(data.begin(), data.end());
	return *this;
}
// 本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序
Foo Foo::sorted() const & {
	Foo ret(*this);	// 拷贝一个副本
	sort(ret.data.begin(), ret.data.end(); // 排序副本
	return ret;	//返回副本
}
```

当我们对一个右值执行sorted时，它可以安全地直接对data成员进行排序。对象是一个右值，意味着没有其他用户，因此我们可以改变对象。当对一个const右值或一个左值执行sorted时，我们不能改变对象，因此就需要在排序前拷贝data。

编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本

**如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符**

