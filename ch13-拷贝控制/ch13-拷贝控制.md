# 拷贝控制

一个类通过定义五种特殊的成员函数来控制【拷贝、移动、赋值和销毁】时做什么，即:

1. 拷贝构造函数(copy constructor)
2. 拷贝赋值运算符（copy-assignment operator)
3. 移动构造函数(move constructor)
4. 移动赋值运算符（move-assignment operator)
5. 析构函数（destructor)

**在定义任何C++类时，拷贝控制操作都是必要部分，如果不显示定义，编译器定义的版本的行为往往出乎意料**

## 13.1.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数

```cpp
class Foo {
public:
	Foo(); // 默认构造函数
	Foo(const Foo&); // 拷贝构造函数
}
```

当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。

当我们使用拷贝初始化（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

**拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的**

### 拷贝初始化发生的情况

1. 使用=定义变量时
2. 将一个对象作为实参传递给一个非引用类型的形参（传值）
3. 从一个返回类型为非引用类型的函数返回一个对象
4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

## 13.1.2 拷贝赋值运算符

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，则编译器会合成一个

拷贝赋值运算符实际上就是个名为operator=的函数，即运算符重载

```cpp
class Foo {
public:
	Foo& operator=(const Foo&); // 赋值运算符
}
```

**赋值运算符通常应该返回一个指向其左侧运算对象的引用**

```cpp
//等价于合成拷贝赋值运算符
Sales_data&
Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo; 	//调用string::operator=
    units_sold = rhs.units_sold;	//使用内置的int赋值
    revenue = rhs.revenue;	//使用内置的double赋值
    return *this;	//返回一个此对象的引用
}
```

 等价于默认合成的拷贝赋值运算符

## 13.1.3 析构函数

析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数

```cpp
class Foo {
public:
	~Foo(); // 析构函数
}
```

在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

### 什么时候会调用析构函数？

无论何时一个对象被销毁，就会自动调用其析构函数：

1. 变量在离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
4. 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
5. 对于临时对象，当创建它的完整表达式结束时被销毁

由于析构函数自动执行，因此程序可以按需分配资源，无需担心何时释放

### 合成析构函数

如果不是被用来阻止该类型的对象被销毁的，则合成析构函数的函数体为空
编译器默认合成的析构函数

```cpp
class Foo {
public:
	~Foo() {  }; // 成员会被自动销毁，除此之外不需要做其他事情 
}
```

等价于合成析构函数，只需要函数体为空即可

**析构函数体自身并不直接销毁成员，成员是在析构函数体之外隐含的析构阶段中被销毁的**

## 13.1.4 三/五法则

1. 拷贝构造函数(copy constructor)

2. 拷贝赋值运算符（copy-assignment operator)

3. 析构函数（destructor)

   

4. 移动构造函数(move constructor)

5. 移动赋值运算符（move-assignment operator)

C++并不要求我们定义所有这些操作，可以只定义其中的一个或两个，但这些操作通常应该被看作一个整体，通常只需要其中一个操作而不需要定义所有操作的情况是很少见的

### 需要析构函数的类也需要拷贝和赋值操作

对析构函数的需求比拷贝构造或赋值的需求更为明显，如果这个类需要一个析构函数，则几乎肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符

### 需要拷贝操作的类也需要赋值操作，反之亦然

如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。

然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

## 13.1.5 使用=default

可以定义=default显示要求编译器生成合成的版本

```cpp
class Sales_data {
public:
    //拷贝控制成员；使用default
    Sales_data() = default;
    Sales_data (const Sales_data&) = default;
    Sales_data& operator=(const Sales_data&);
    ~Sales_data () = default;
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

当我们在类内使用=default时，合成的函数将隐式声明为内联，如果不希望时内联，则应该对成员的类外定义使用=default

## 13.1.6 阻止拷贝

**大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式还是显示**

我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(deleted function)

```cpp
struct NoCopy {
	NoCopy() = default;	//使用合成的默认构造函数
	NoCopy(const NoCopy&) = delete;	//阻止拷贝
	NoCopy &operator=(const NoCopy&) = delete;	//阻止赋值
	~NoCopy() = default; //使用合成的析构函数
}
```

=delete通知编译器和代码的读者，我们不希望定义这些成员

与=default不同，=delete必须出现在函数第一次声明的时候，同时可以对任何函数指定=delete（只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）

### 不应该删除析构函数

我们不应该删除析构函数，对于一个删除了析构函数的类型，我们不能定义该类型的变量或临时对象，该成员无法被销毁。

虽然对于删除了析构函数的类型，我们不能定义这种类型的变量或成员，但是可以动态分配这种类型的对象，**不能释放**

```cpp
struct NoDtor {
	NoDtor(）= default; 	//使用合成默认构造函数
	~NoDtor()）= delete;	//我们不能销毁NoDtor类型的对象
}
NoDtor nd;	//错误：NoDtor的析构函数是删除的
NoDtor *p = new NoDtor();	// 正确:但我们不能 delete p
delete p;	//错误：NoDtor的析构函数是删除的
```

### 合成的拷贝控制成员可能是删除的

对于某些类来说，编译器可能将合成的成员定义为删除的函数

- 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的)，则类的合成析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函
  数被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

**本质上：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的**

## 13.2 拷贝控制和资源管理

