# 6.1 函数基础

## 实参与形参

1. 实参是形参的初始值，实参的类型必须与形参匹配
2. 形参列表中的形参类型必须写明
3. 任意两个形参不能同名
4. 函数最外层作用域中的局部变量也不能使用与函数形参一样的名字

## 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针

# 6.1.1 局部对象

## 作用域与生命周期

名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见
- 对象的生命周期是程序执行过程中该对象存在的一段时间

## 自动对象

（第一次听这个名词）

我们把只存在于块执行期间的对象称作**自动对象（automatic object）**，当块的执行结束后，块中创建的自动对象的值就变成未定义的了

形参就是一种自动对象

## 局部静态对象

static，在执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁

# 6.1.2 函数声明

## 函数声明

函数只能定义一次，但能声明多次

函数声明不包含函数体，所以也就无须形参的名字，在函数的声明中经常省略形参的名字。但写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能

函数的三要素**（返回类型，函数名，形参类型）**描述了函数的接口，说明了调用该函数需要的全部信息，函数声明也称作函数原型

# 6.1.3 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件单独编译

```shell
gcc factMain.cc fact.cc # 生成factMain.exe or a.out
gcc factMain.cc fact.cc -o main # 生成main or main.exe
```

如果我们修改了其中一个源文件，我们只需要重新编译改动过的文件，大多数编译器都提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是 .obj (Windows)或 .o (Unix)的文件，后缀名的含义是该文件包含对象代码(object code)

接下来编译器负责把对象文件链接在一起形成可执行文件

```shell
gcc -c factMain.cc # 生成factMain.o
gcc -c fact.cc # 生成fact.o
gcc factMain.o fact.o # 生成factMain.exe or a.out
gcc factMain.o fact.o -o main # 生成main.exe or main
```

# 6.2 参数传递

## 传引用和传值

如果形参是引用类型，则将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参

当形参是引用类型，我们说传引用，当实参的值被拷贝给形参时，我们说这样是传值

## 指针形参

指针的行为和其他的非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针

**建议：熟悉C的程序员常常使用指针类型的形参访问函数外部的对象，但在C++中，建议使用引用类型的形参代替指针**

# 6.2.2 传引用参数

## 使用传引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

**当函数无需修改引用形参的值时，最好使用常量引用**

## 使用引用形参返回额外信息

（感觉非常实用）

一个函数只能返回一个值，然而有时候函数需要返回多个值，引用形参为我们一次返回多个结果提供了有效的途径

我们可以把实参传入，实参在函数运行后值会改变，变相返回了额外信息

# 6.2.3 const形参和实参

当用实参初始化形参时会忽略掉顶层const，换句话说，形参的顶层const被忽略掉了，这就意味着

```cpp
void fcn(const int i) { }
void fcn(int i) { }
```

二者时同样的定义，会报错

## 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。

此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

# 6.2.4 数组形参

## 数组的特殊性质对函数的影响

数组的两个特殊性质对于我们定义和使用作用在数组上的函数有影响

1. 不允许拷贝数组
2. 使用数组时通常会将其转换为指针

因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以我们传递一个数组时，实际上传递的是指向数组首元素的指针

## 数组的确切尺寸

因为数组是以指针的形式传递的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些外信息

1. 使用标记指定数组长度：使用C风格字符串时，最后会跟一个空字符，可以用这个空字符作为数组结束的标记
2. 使用标准库规范：传递数组的首元素和尾后元素指针
3. 显式传递一个表示数组大小的形参：例如传一个size_t size

# 6.2.5 main:处理命令行选项

main函数一般都只有空形参列表，但有时我们确实需要给main传递实参，例如main函数位于可执行文件prog内

```shell
prog -d -o ofile data0
```

通过两个可选形参传递给main函数

```cpp
int main(int argc, char *argv[]) { }
int main(int argc, char **argv) { } // 也可以这么写
// 意味着argv是一个指针，指向char *
```

`argc`（**argument count**）是传给程序的**命令行参数的个数**。

`argv`（**argument vector**）是一个**字符串数组**，类型是 `char *argv[]` 或 `char **argv`。

当实参传递给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参，最后一个指针的元素值保证为0

```cpp
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始，argv[0]保存程序的名字，而非用户输入**