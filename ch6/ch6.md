# 6.1 函数基础

## 实参与形参

1. 实参是形参的初始值，实参的类型必须与形参匹配
2. 形参列表中的形参类型必须写明
3. 任意两个形参不能同名
4. 函数最外层作用域中的局部变量也不能使用与函数形参一样的名字

## 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针

# 6.1.1 局部对象

## 作用域与生命周期

名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见
- 对象的生命周期是程序执行过程中该对象存在的一段时间

## 自动对象

（第一次听这个名词）

我们把只存在于块执行期间的对象称作**自动对象（automatic object）**，当块的执行结束后，块中创建的自动对象的值就变成未定义的了

形参就是一种自动对象

## 局部静态对象

static，在执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁

# 6.1.2 函数声明

## 函数声明

函数只能定义一次，但能声明多次

函数声明不包含函数体，所以也就无须形参的名字，在函数的声明中经常省略形参的名字。但写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能

函数的三要素**（返回类型，函数名，形参类型）**描述了函数的接口，说明了调用该函数需要的全部信息，函数声明也称作函数原型

# 6.1.3 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件单独编译

```shell
gcc factMain.cc fact.cc # 生成factMain.exe or a.out
gcc factMain.cc fact.cc -o main # 生成main or main.exe
```

如果我们修改了其中一个源文件，我们只需要重新编译改动过的文件，大多数编译器都提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是 .obj (Windows)或 .o (Unix)的文件，后缀名的含义是该文件包含对象代码(object code)

接下来编译器负责把对象文件链接在一起形成可执行文件

```shell
gcc -c factMain.cc # 生成factMain.o
gcc -c fact.cc # 生成fact.o
gcc factMain.o fact.o # 生成factMain.exe or a.out
gcc factMain.o fact.o -o main # 生成main.exe or main
```

# 6.2 参数传递

## 传引用和传值

如果形参是引用类型，则将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参

当形参是引用类型，我们说传引用，当实参的值被拷贝给形参时，我们说这样是传值

## 指针形参

指针的行为和其他的非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针

**建议：熟悉C的程序员常常使用指针类型的形参访问函数外部的对象，但在C++中，建议使用引用类型的形参代替指针**

# 6.2.2 传引用参数

## 使用传引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

**当函数无需修改引用形参的值时，最好使用常量引用**

## 使用引用形参返回额外信息

（感觉非常实用）

一个函数只能返回一个值，然而有时候函数需要返回多个值，引用形参为我们一次返回多个结果提供了有效的途径

我们可以把实参传入，实参在函数运行后值会改变，变相返回了额外信息

# 6.2.3 const形参和实参

当用实参初始化形参时会忽略掉顶层const，换句话说，形参的顶层const被忽略掉了，这就意味着

```cpp
void fcn(const int i) { }
void fcn(int i) { }
```

二者时同样的定义，会报错

## 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。

此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

# 6.2.4 数组形参

## 数组的特殊性质对函数的影响

数组的两个特殊性质对于我们定义和使用作用在数组上的函数有影响

1. 不允许拷贝数组
2. 使用数组时通常会将其转换为指针

因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以我们传递一个数组时，实际上传递的是指向数组首元素的指针

## 数组的确切尺寸

因为数组是以指针的形式传递的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些外信息

1. 使用标记指定数组长度：使用C风格字符串时，最后会跟一个空字符，可以用这个空字符作为数组结束的标记
2. 使用标准库规范：传递数组的首元素和尾后元素指针
3. 显式传递一个表示数组大小的形参：例如传一个size_t size

# 6.2.5 main:处理命令行选项

main函数一般都只有空形参列表，但有时我们确实需要给main传递实参，例如main函数位于可执行文件prog内

```shell
prog -d -o ofile data0
```

通过两个可选形参传递给main函数

```cpp
int main(int argc, char *argv[]) { }
int main(int argc, char **argv) { } // 也可以这么写
// 意味着argv是一个指针，指向char *
```

`argc`（**argument count**）是传给程序的**命令行参数的个数**。

`argv`（**argument vector**）是一个**字符串数组**，类型是 `char *argv[]` 或 `char **argv`。

当实参传递给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参，最后一个指针的元素值保证为0

```cpp
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始，argv[0]保存程序的名字，而非用户输入**

# 6.2.6 含有可变形参的函数

实参类型相同：initializer_list 标准库类型
实参类型不同：编写可变参数模板
特殊：省略符形参

## initializer_list

如果实参数量位置，但是实参类型全部相同，可以使用initializer_list类型的形参，可以用于表示某种特定类型的值的数组

```cpp
initializer_list<T> lst;
```

initializer_list也是一种模板类型，且其中的元素永远是常数值，无法改变其中元素的值

如果想向 il 中传递一个值的序列，则必须把序列放在一对花括号内

```cpp
if (expected != actual) {
	error_msg({"functionX", expected, actual});
} else {
	error_msg({"functionX", "okay"});
}
```

## 省略符形参

省略符形参是为了便于C++程序访问某些特殊的C代码设置的，这些代码使用了名为varargs的C标准库功能

```
void foo(parm_list, ...);
void foo(...);
```

# 6.3 return

## 不要返回局部对象的引用或指针

返回局部对象的引用和指针是错误的，一旦函数完成，局部对象将被释放，指针将指向一个不存在的对象

## 引用返回左值

函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数得到左值，其他返回类型得到右值

```cpp
char &get_val(string &str, string::size_type ix) {
	return str[ix];
}
int main() {
	string s("a value");
	cout << s << endl;
	get_val(s, 0) = 'A';
	cout << s << endl;
}
```

上述代码完全是对的，第一次输出会输出a value，第二次输出则是A value，因为函数可以返回左值，因此可以出现在赋值运算符的左侧

## 列表初始化返回值

C++11规定，函数可以返回花括号包围的值的列表

```cpp
return {"functionX", expected, autual};
```

## 递归

**如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数**

但main函数不能调用它自己

## 尾置返回类型

C++11可以使用尾置返回类型，任何函数的定义都能使用尾置返回，定义返回类型比较复杂的函数最有用，比如返回类型是数组的指针或引用

```cpp
auto func(int i) -> int(*)[10];
```

# 6.5.2 内联函数与constexpr函数

## 内联函数

调用函数虽然方便，但是存在潜在的性能开销，会比直接使用对应的表达式慢，因此可以使用内联函数

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开

```cpp
cout << shorterString(s1, s2) << endl;
```

在编译过程中会展开成类似于下面的格式

```cpp
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

从而消除了函数的运行时开销

只要通过在函数的返回类型前面加上关键字 inline 就可以将其声明成内联函数

**但内联说明只是向编译器做出请求，编译器可以忽略这个请求，也就是内联不一定会生效**

## constexpr

constexpr函数是指能用于常量表达式的函数，不过要遵循几项约定：

1. 函数的返回类型及所有形参的类型都得是字面值类型
2. 函数体中必须有且只有一条return语句

```cpp
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();
```

执行初始化任务时，编译器会把对constexpr函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr被隐式地指定为内联函数

# 6.5.3 调试帮助

## assert与NDEBUG

assert的行为依赖于NDEBUG预处理变量的状态，如果定义了NDEBUG，则assert什么也不做，默认状态下没有定义NDEBUG，此时assert将执行运行时检查

## \_\_xxx\_\_

1. \_\_func\_\_，可以输出当前调试的函数的名字，编译器为每个函数都定义了\_\_func\_\_
2. \_\_FILE\_\_，存放文件名的字符串字面值
3. \_\_LINE\_\_，存放当前行号的整形字面值
4. \_\_TIME\_\_，存放文件编译时间的字符串字面值
5. \_\_DATE\_\_，存放文件编译日期的字符串字面值

# 6.7 函数指针

函数指针指向的是函数并非对象，函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定，**与函数名无关**

```cpp
bool lengthCompare(const string &, const string &);
// pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (pf*)(const string &, const string &);

// 这也是一个函数指针
using PF = int(*)(int*, int);
```

(*pf)两端的括号必不可少，如果不写这对括号，则pf是一个返回值为bool指针的函数

当我们把函数名作为一个值使用时，该函数自动地转换成指针，例如：

```cpp
pf = lengthCompare; // pf指向名为lengthCompare的函数
pf = &lengthCompare; // 等价的赋值语句：取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针

```cpp
bool b1 = pf("hello", "goodbye"); // 调用lengthCompare函数
bool b2 = (*pf)("hello", "goodbye"); // 一个等价的调用
bool b3 = lengthCompare("hello", "goodbye"); // 另一个等价的调用
```

## 返回指向函数的指针

（沟槽的C++

意思是返回函数指针

```cpp
int (*f1(int))(int*, int);
```

由内向外，看到f1有形参列表，f1是个函数，f1前面有*，f1返回一个指针，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int

为了身心健康，还是写成尾置返回类型吧！

```cpp
// 等价于
auto f1(int) -> int (*)(int*, int);
```

f1是个函数，形参列表是int，返回值是一个函数指针
好理解太多太多！

