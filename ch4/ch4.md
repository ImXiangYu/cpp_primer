# 4.1 表达式基础

## 左值和右值

一个左值表达式的求值结果是一个对象或者一个函数，虽然某些表达式的求值结果是对象，但它们实际是右值而非左值

简单归纳为：当一个对象被用作**右值**时，用的是**对象的值（内容）**，被用作左值时，用的是**对象的身份（在内存中的位置）**

## 处理符合表达式

1. 拿不准的时候用括号
2. 如果改变了某个运算对象的值，则表达式的其他地方不要再用这个运算对象

# 4.3 逻辑和关系运算符

## 短路求值

逻辑与和逻辑或都是先求左侧运算对象的值，再求右侧运算对象的值，只有当左侧运算对象无法确定表达式的结果时，才会计算右侧运算对象的值，这种策略被称作**短路求值**

# 4.5 递增和递减运算符

## 前置与后置

前置版本的递增是先将对象加1，然后将改变后的对象作为求值结果。
后置版本的递增也会将对象加1，但是求值结果是运算对象改变之前的那个值的副本。

```cpp
int i = 0, j;
j = ++i; // j = 1, i = 1，前置版本得到递增后的值
```

```cpp
int i = 0, j;
j = i++; // j = 0, i = 1，后置版本得到递增前的值
```

递增和递减运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回

**注意：建议除了非必须，否则不用后置版本，坚持使用前置版本++i**，原因是后置版本需要将原始值存储下来以便返回这个未修改的内容，而对于整数和指针类型来说，编译器可能会有一定的优化，但是对于复杂的迭代器类型，这种额外工作的消耗就巨大了。

## 混用解引用和递增运算符

```cpp
*pbeg++
*(pbeg++)
```

二者等价，且*pbeg++这种写法十分普遍，由于后置递增运算符的优先级高于解引用，因此会把pbeg的值加1，并返回pbeg的初始值的副本作为其求值结果，此时解引用的运算对象是pbeg未增加之前的值

# 4.8 位运算符

## 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看作是二进制位的集合，位运算符提供设置和检查二进制位的功能

位运算符右侧的运算对象一定不能为负，并且值必须严格小于结果的位数，否则就会产生未定义行为

![shift](D:\cpp_primer\ch4\shift.png)

# 4.9 sizeof运算符

## sizeof

sizeof所得的值是一个size_t类型的常量表达式，其运算符的运算对象有两种形式：
```cpp
sizeof (type)
sizeof expr
```

sizeof并不实际计算其运算对象的值，所以即使是sizeof (*p)，p是未初始化的指针也没问题，因为sizeof没有真的解引用指针，指针也没有真的被使用

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1。
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。
- 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。（即vector对象本身的大小）

因为执行sizeof可以得到整个数组的大小，所以可以用数组大小除以单个元素的大小得到数组中元素的个数

# 4.10 逗号运算符

说真的我都不知道有这个运算符（😓

逗号运算符按照从左向右的顺序依次求值

对逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉，**真正的结果是右侧表达式的值**，如果右侧运算对象是左值，那么最终的求值结果也是左值

感觉用处不大~？

# 4.11 类型转换

## 隐式转换

何时发生隐式类型转换：

1. 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
2. 在条件中，非布尔值转换成布尔类型
3. 初始化过程中，初始值转变成变量的类型
4. 在赋值语句中，右侧运算对象转换成左侧运算对象的类型
5. 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型

## 其他隐式类型转换

1. **数组转换成指针**，在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。但当数组被用作decltype关键字的参数、作为取地址符、sizeof及typeid等运算符的运算对象时，上述转换不会发生。
2. **指针的转换**，0或者字面值nullptr可以转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void\*，
3. **转换成布尔类型**，如果指针或算术类型的值是0，则转换成false，否则为true
4. **转换成常量**，允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样，但相反的转换并不存在，因为它在试图删除掉底层const
5. **类类型定义的转换**，类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换

# 4.11.1 算数转换

## 整型提升

整型提升负责把小整数类型转换成较大的整数类型

## 无符号类型的运算对象

如果一个运算对象是无符号类型，另一个运算对象是带符号类型，其中无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的

# 4.11.3 显式转换

## 强制类型转换

形式如下

```cpp
cast-name<type>(expression);
```

其中，type是转换的目标类型，expression是要转换的值，如果type是引用类型，则结果是左值

cast-name是static_cast, dynamic_cast, const_cast, reinterpret_cast中的一种

## static_cast

任何具有明确定义的类型转换，只要不包含底层const，就能使用static_cast

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用

## const_cast

const_cast只能改变运算对象的底层const，对于将常量对象转换成非常量对象的行为，我们一般叫“去掉const性质”，一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了

其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误

## 避免强制类型转换

强烈建议程序员避免使用强制类型转换！