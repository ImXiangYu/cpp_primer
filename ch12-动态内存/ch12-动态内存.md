# ch12 动态内存

## 静态内存、栈内存、堆内存

- 静态内存用来保存局部static对象、类static数据成员，以及定义在任何函数之外的变量

- 栈内存用来保存定义在函数内的非static对象

- 堆内存用来存储动态分配的对象——即在程序运行时分配的对象，动态对象

分配在静态内存或栈内存中的对象由编译器自动创建和销毁；对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。

动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显示地销毁它们

# 12.1 动态内存与智能指针

## 12.1.1 shared_ptr

智能指针的使用方式与普通指针类似，解引用一个智能指针返回它指向的对象。
如果在一个条件判断中使用智能指针，效果就是检测它是否为空

```cpp
p.get() // 可以返回p中所保存的指针
```

### make_shared

```cpp
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10, '9'); // 9999999999, 10个9
shared_ptr<int> p5 = make_shared<int>(); // 0
```

推荐使用auto，使得定义更简单

```cpp
auto p6 = make_shared<vector<string>>();
```

### shared_ptr的拷贝和赋值

当进行拷贝或赋值时，每个shared_ptr会记录有多少个其他shared_ptr指向相同的对象

每个shared_ptr都有一个关联的计数器，通常称为**引用计数**，无论何时拷贝一个shared_ptr，计数器都会递增。将一个shared_ptr赋予另一个shared_ptr会递增赋值号右侧shared_ptr的引用计数，而递减左侧sp的引用计数

当我们给shared_ptr一个新值或者shared_ptr被销毁时，计数器会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象

### 对象与关联的内存

shared_ptr会自动销毁所管理的对象，还会自动释放相关联的内存

### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：

1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象间共享数据

## 12.1.2 直接管理内存new&delete

### 使用new动态分配和初始化对象

在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，返回一个指向该对象的指针

```cpp
int *pi = new int; // pi指向一个动态分配的、未初始化的无名对象
```

可以使用圆括号（传统的构造方式）或花括号（列表初始化）来初始化一个动态分配的对象

```cpp
int *pi = new int(1024); // pi 指向的对象的值为1024
string *ps = new string(10, '9'); // *ps 为"9999999999"
vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

// 也可以使用默认初始化
int *pi1 = new int;
int *pi2 = new int(); // 即加一对空括号，会使用默认构造函数
```

**尽量对动态分配的对象进行初始化**

### 内存耗尽

当new不能分配所要求的内存空间时，会抛出bad_alloc的异常，我们可以改变new的方式来组织它抛出异常

```cpp
int *p1 = new int;
int *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针
```

称之为定位new(placement new)，定位new表达式允许我们向new传递额外的参数

### delete

```cpp
delete p; // p必须指向一个动态分配的对象或是一个空指针
```

delete之后记得重置指针值，不然其指向的内存已经被释放，但是指针仍指向那个位置

### 易错点

1. 忘记delete内存，出现内存泄漏
2. 使用已经释放掉的内存
3. 同一块内存释放两次

**因此要坚持只使用智能指针，避免这些问题！对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它**

## 12.1.3 shared_ptr与new

不要混合使用普通指针和智能指针

不要使用get初始化另一个智能指针或为智能指针赋值

只有在确定代码不会delete指针的情况下才使用get

### unique & reset

可以用reset将一个新的指针赋予一个sp，reset会更新引用计数，如果需要也会释放p指向的对象。reset经常与unique一起使用，来控制多个sp共享的对象

```cpp
if (!p.unique())
	p.reset(new string(*p));
*p += newVal;
```

自从C++17起，推荐使用**use_count()**

```cpp
if (p.use_count() != 1) {
    p.reset(new std::string(*p));
}
*p += newVal;
```

完全等价

## 12.1.5 unique_ptr

一个up**拥有**它所指向的对象，与sp不同，某个时刻只能有一个up指向一个给定对象，当up被销毁时，所指对象也会被销毁

与sp不同，没有make_shared，当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，初始化up必须使用直接初始化形式

```cpp
unique_ptr<double> p1; // 可以指向一个double的up
unique_ptr<int> p2(new int(42)); // p2 指向一个值为42的int
```

由于unique_ptr拥有它指向的对象，因此其不支持普通的拷贝或赋值

```cpp
unique_ptr<string> p1(new string("123"));
unique_ptr<string> p2(p1); // 错误，up不支持拷贝
unique_ptr<string> p3;
p3 = p2; // 错误，up不支持赋值
```

### 将要销毁的unique_ptr

我们可以拷贝或赋值一个将要销毁的unique_ptr

```cpp
unique_ptr<int> clone(int p) {
	return unique_ptr<int>(new int(p)); // 正确，从int*创建一个unique_ptr<int>
}

// 或局部对象的拷贝
unique_ptr<int> clone(int p) {
    unique_ptr<int> ret(new int(p));
    return ret;
}
```

对于两段代码，编译器都知道要返回的对象将要被销毁

### 向unique_ptr传递删除器

up默认使用delete释放它指向的对象，我们可以重载一个up中的默认删除器

我们在创建或reset一个重载了删除器的up对象时，必须提供一个指定类型的可调用对象（删除器）

```cpp
unique_ptr<objT, delT> p (new objT, fcn);
// p 指向一个类型为objT的对象，并使用一个类型为delT的对象来释放objT对象
// 它会调用一个名为fcn的delT类型对象
```

## 12.1.6 weak_ptr

weak_ptr是一种不控制所指对象生存期的智能指针，它指向由一个sp管理的对象，将一个wp绑定到一个sp不会改变sp的引用计数，一旦最后一个指向对象的sp被销毁，对象就会被释放，即使有wp指向对象

当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它

```cpp
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); // wp弱共享p，p的引用计数未改变
```

我们不能直接使用weak_ptr访问对象，必须调用lock，此函数检查wp指向的对象是否仍然存在，如果存在，则返回一个指向共享对象的sp

```cpp
if (shared_ptr<int> np = wp.lock()) {
	// 如果np不为空则条件成立
	// 在if中，np与p共享对象
}
```

这几行代码做了什么？

1. 调用 `wp.lock()` 尝试获取一个 `shared_ptr<int>`。
2. 将 `lock()` 的返回值赋给一个新的局部变量 `np`（类型为 `shared_ptr<int>`）。
3. 将赋值的结果（即 `np`）作为 `if` 语句的条件进行判断。

- **如果 `wp` 指向的对象仍然存在**：`lock()` 返回一个有效的 `shared_ptr`，`np` 不为空，`if` 条件为真，进入 `if` 块。
- **如果 `wp` 指向的对象已经被销毁**：`lock()` 返回一个空的 `shared_ptr`，`np` 为空，`if` 条件为假，跳过 `if` 块。

一旦进入 `if` 块，说明 `lock()` 成功了，`np` 是一个有效的 `shared_ptr`，它和原来的 `shared_ptr`（比如 `p`）**共同指向同一个对象**，并且都会增加该对象的引用计数。这意味着在 `if` 块执行期间，该对象**不会被销毁**，因为至少有两个 `shared_ptr`（`np` 和原来的 `p`）在引用它。

## 智能指针的操作

### shared_ptr

`std::shared_ptr` 是 C++11 引入的一种智能指针类型，它通过引入引用计数机制来自动管理动态分配的对象的生命周期。以下是一些常用的 `std::shared_ptr` 操作和成员函数：

1. **创建 shared_ptr**：
   - `std::make_shared<T>(args...)`: 创建一个指向类型 T 的新对象的 `shared_ptr`，并使用 args 初始化。
   - `std::shared_ptr<T> p(new T);` 或 `auto p = std::shared_ptr<T>(new T);`: 使用 new 分配并初始化一个对象，并将所有权交给 `shared_ptr`。
2. **获取引用计数**：
   - `p.use_count()`: 返回与该智能指针共享对象的 `shared_ptr` 实例的数量（即引用计数）。
3. **检查是否为 null**：
   - `p.get()`: 返回存储在 `shared_ptr` 中的对象指针。如果 `shared_ptr` 为空，则返回 `nullptr`。
   - `p == nullptr` 或 `p != nullptr`: 检查 `shared_ptr` 是否持有对象。
   - `p.reset()`: 如果这是最后一个 `shared_ptr` 实例并且释放了其拥有的对象，则将其设置为 `nullptr`。
4. **管理对象所有权**：
   - `p.unique()`: 判断是否是唯一拥有者（即引用计数是否为 1）。注意，在多线程环境下这个方法可能会产生竞态条件。
   - `p.swap(q)`: 交换两个 `shared_ptr` 实例 p 和 q 所拥有的对象。
   - `std::swap(p, q)`: 同样可以用来交换两个 `shared_ptr` 实例所拥有的对象。
5. **访问对象**：
   - `p.operator*()` 或 `*p`: 解引用操作符，用于访问智能指针指向的对象。
   - `p.operator->()` 或 `p->`: 成员访问操作符，用于调用智能指针指向对象的成员函数或访问成员变量。
6. **其他**：
   - `p.owner_before(q)`: 提供基于所有权的比较，可用于集合中对 `shared_ptr` 进行排序。

### unique_ptr

`std::unique_ptr` 是另一种在 C++11 中引入的智能指针，旨在提供独占所有权的语义来管理动态分配的对象。与 `std::shared_ptr` 不同，`std::unique_ptr` 不能进行拷贝，但支持移动语义，从而允许资源的所有权安全且高效地转移。以下是 `std::unique_ptr` 的一些常用操作和成员函数：

1. **创建 unique_ptr**：
   - `std::make_unique<T>(args...)`: 创建一个指向类型 T 的新对象的 `unique_ptr`，并使用 args 初始化。注意 `make_unique` 是从 C++14 开始提供的。
   - `std::unique_ptr<T> p(new T);` 或 `auto p = std::unique_ptr<T>(new T);`: 使用 new 分配并初始化一个对象，并将所有权交给 `unique_ptr`。推荐使用 `make_unique` 以获得更好的安全性和异常安全性。

2. **释放资源**：
   - `p.release()`: 放弃对所管理对象的所有权并返回指向该对象的裸指针。调用后，`unique_ptr` 不再管理任何对象。
   - `p.reset()`: 删除所管理的对象并可选地接收一个新的指针来管理。
   - `p.reset(nullptr)`: 将 `unique_ptr` 置为空。

3. **获取底层指针**：
   - `p.get()`: 返回存储在 `unique_ptr` 中的对象指针。这不会放弃所有权。

4. **所有权转移**：
   - 移动构造函数和移动赋值操作符：`std::unique_ptr` 支持通过移动语义来转移所有权。这意味着你可以使用标准库算法和容器（如 `std::vector`）来存储 `unique_ptr`，只要这些操作不涉及拷贝即可。
   - `std::move(p)`: 显式地将 `unique_ptr` 转换为右值，使得可以将其所有权转移给另一个 `unique_ptr`。

5. **访问所管理对象**：
   - `p.operator*()` 或 `*p`: 解引用操作符，用于访问智能指针指向的对象。
   - `p.operator->()` 或 `p->`: 成员访问操作符，用于调用智能指针指向对象的成员函数或访问成员变量。

6. **检查是否持有对象**：
   - `if (p) {...}` 或 `if (!p) {...}`: 检查 `unique_ptr` 是否持有对象（即它不是空的）。

7. **自定义删除器**：
   - `std::unique_ptr<T, Del>`: 可以指定一个删除器用于定制如何释放资源。这对于管理需要特殊清理过程的资源（例如文件句柄、网络连接等）非常有用。

### weak_ptr

`std::weak_ptr` 是 C++11 引入的一种智能指针，它**不拥有**所指向对象的生命周期，而是“弱引用”一个由 `std::shared_ptr` 管理的对象。它的主要用途是**打破循环引用**，并提供一种安全的方式来观察共享对象是否仍然存在。

以下是 `std::weak_ptr` 的常用成员函数和操作：

1. **创建 weak_ptr**

   - `std::weak_ptr<T> wp;` 
     默认构造，创建一个空的 `weak_ptr`。

   - `std::weak_ptr<T> wp(sp);` 
     从一个 `std::shared_ptr<T>` 构造，不会增加引用计数。

   - `wp = sp;` 或 `wp = another_wp;` 
     支持赋值操作，可以从 `shared_ptr` 或另一个 `weak_ptr` 赋值。


> ⚠️ 注意：`std::weak_ptr` 不能通过 `new` 直接构造，也不能使用 `std::make_shared` 或 `std::make_unique` 创建。

2. **检查对象状态**

   - `wp.expired()` 
     检查它所观察的对象是否已经被销毁（即最后一个 `shared_ptr` 已释放）。 
     返回 `true` 表示对象已不存在，`false` 表示仍存在。

   - `wp.use_count()` 
     返回当前与该对象关联的 `shared_ptr` 的引用计数。 
     可用于判断还有多少个 `shared_ptr` 正在共享该对象。

3. **获取 shared_ptr（提升为强引用）**

- `wp.lock()` **最核心的操作** 
  尝试将 `weak_ptr` “提升”为 `std::shared_ptr`：
  
  - 如果对象仍然存在，返回一个有效的 `std::shared_ptr<T>`。
  - 如果对象已被销毁，返回一个空的 `std::shared_ptr<T>`（即相当于 `nullptr`）。
  
  示例：
  ```cpp
  std::shared_ptr<MyClass> shared = wp.lock();
  if (shared) {
      // 安全访问对象
      shared->do_something();
  } else {
      // 对象已被释放
      std::cout << "Object is gone.\n";
  }
  ```
  
  > `lock()` 是线程安全的，适合在多线程环境中使用。

4. **释放或重置观察目标**
   - `wp.reset()` 
     停止观察当前对象，使 `weak_ptr` 变为空。

5. **交换操作**

   - `wp.swap(other)` 
     与另一个 `weak_ptr` 交换所观察的对象。

   - `std::swap(wp, other)` 
     标准库提供的交换函数。

6. **比较操作**
   - 支持 `==`, `!=`, `<`, `<=`, `>`, `>=` 比较，可用于在容器（如 `std::set`、`std::map`）中作为键使用。

7. **访问底层资源**

   - ❌ `std::weak_ptr` **没有** `operator->` 和 `operator*`，不能直接解引用。

   - ✅ 必须先调用 `lock()` 获得 `shared_ptr` 后才能访问对象。

# 12.2 动态数组

## 12.2.1 new和数组

### 分配一个动态数组会得到一个元素类型的指针

当new分配一个动态数组时，会得到一个数组元素类型的指针，由于分配的内存并不是一个数组类型，因此不能对动态数组使用begin或end，也不能使用range-for

### 动态分配一个空数组

当我们new分配一个大小为0的数组是，new返回一个合法的非空指针，对于0长度的数组来说，这个指针就像尾后指针一样，我们可以像用尾后迭代器一样用这个指针，可以加上0，也可以减去0，但不能解引用——因为它不指向任何元素

### 释放动态数组

```cpp
delete p;
delete [] pa;
```

第二条语句逆序销毁数组中的元素，即最后一个元素首先被销毁，然后是倒数第二个，以此类推

当我们释放一个指向数组的指针时，空方括号对是必须的，它指示编译器此指针指向一个对象数组的第一个元素

### 智能指针和动态数组

标准库提供了一个可以管理new分配的数组的unique_ptr版本

```cpp
unique_ptr<int []> up(new int[10]);
up.release(); // 自动用delete[]销毁其指针
```

当一个up指向一个数组时，我们不能用点和箭头成员运算符，毕竟up指向的是一个数组而不是单个对象，但我们可以用下标运算符来访问数组中的元素

```cpp
for (size_t i = 0; i != 10; ++i) 
	up[i] = i;
```

## 12.2.2 allocator类

和vector一样，是一个模板

```cpp
allocator<string> alloc;
auto const p = alloc.allocate(n);
```

这个allocate调用为n个string分配了内存

### allocator类及其算法

![allocator](D:\cpp_primer\ch12\allocator.png)

### 分配的是未构造的内存

allocator分配的内存是未构造的，我们按需要在此内存中构造对象，**为了使用allocate返回的内存，我们必须用construct构造对象，使用未构造的内存，其行为是未定义的**

**且只能对真正构造了的元素进行destory操作**
